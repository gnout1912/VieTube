{
  "version": 3,
  "sources": ["src/app/shared/shared-main/common/infinite-scroller.directive.ts"],
  "sourcesContent": ["import { AfterViewChecked, booleanAttribute, Directive, ElementRef, inject, input, OnDestroy, OnInit, output } from '@angular/core'\nimport { PeerTubeRouterService } from '@app/core'\nimport { fromEvent, Observable, Subscription } from 'rxjs'\nimport { distinctUntilChanged, filter, map, share, startWith, throttleTime } from 'rxjs/operators'\n\n@Directive({\n  selector: '[myInfiniteScroller]',\n  standalone: true\n})\nexport class InfiniteScrollerDirective implements OnInit, OnDestroy, AfterViewChecked {\n  private peertubeRouter = inject(PeerTubeRouterService)\n  private el = inject(ElementRef)\n\n  readonly percentLimit = input(70)\n  readonly onItself = input(false, { transform: booleanAttribute })\n  readonly dataObservable = input<Observable<any[]>>(undefined)\n\n  readonly nearOfBottom = output()\n\n  private decimalLimit = 0\n  private lastCurrentBottom = -1\n  private scrollDownSub: Subscription\n  private container: HTMLElement\n\n  private checkScroll = false\n\n  constructor () {\n    this.decimalLimit = this.percentLimit() / 100\n  }\n\n  ngAfterViewChecked () {\n    if (this.checkScroll) {\n      this.checkScroll = false\n\n      // Wait HTML update\n      setTimeout(() => {\n        if (this.hasScroll() === false) this.nearOfBottom.emit()\n      })\n    }\n  }\n\n  ngOnInit () {\n    this.initialize()\n  }\n\n  ngOnDestroy () {\n    if (this.scrollDownSub) this.scrollDownSub.unsubscribe()\n  }\n\n  initialize () {\n    this.container = this.onItself()\n      ? this.el.nativeElement\n      : document.documentElement\n\n    // Emit the last value\n    const throttleOptions = { leading: true, trailing: true }\n\n    const scrollableElement = this.onItself() ? this.container : window\n    const scrollObservable = fromEvent(scrollableElement, 'scroll')\n      .pipe(\n        startWith(true),\n        throttleTime(200, undefined, throttleOptions),\n        map(() => this.getScrollInfo()),\n        distinctUntilChanged((o1, o2) => o1.current === o2.current),\n        share()\n      )\n\n    // Scroll Down\n    this.scrollDownSub = scrollObservable\n      .pipe(\n        filter(({ current }) => this.isScrollingDown(current)),\n        filter(({ current, maximumScroll }) => (current / maximumScroll) > this.decimalLimit)\n      )\n      .subscribe(() => {\n        this.nearOfBottom.emit()\n      })\n\n    const dataObservable = this.dataObservable()\n    if (dataObservable) {\n      dataObservable\n        .pipe(filter(d => d.length !== 0))\n        .subscribe(() => this.checkScroll = true)\n    }\n  }\n\n  private getScrollInfo () {\n    return { current: this.container.scrollTop, maximumScroll: this.getMaximumScroll() }\n  }\n\n  private getMaximumScroll () {\n    const elementHeight = this.onItself() ? this.container.clientHeight : window.innerHeight\n\n    return this.container.scrollHeight - elementHeight\n  }\n\n  private hasScroll () {\n    return this.getMaximumScroll() > 0\n  }\n\n  private isScrollingDown (current: number) {\n    const result = this.lastCurrentBottom < current\n\n    this.lastCurrentBottom = current\n    return result\n  }\n}\n"],
  "mappings": "kLASA,IAAaA,GAAyB,IAAA,CAAhC,IAAOA,EAAP,MAAOA,CAAyB,CAC5BC,eAAiBC,EAAOC,CAAqB,EAC7CC,GAAKF,EAAOG,CAAU,EAErBC,aAAeC,EAAM,EAAE,EACvBC,SAAWD,EAAM,GAAO,CAAEE,UAAWC,CAAgB,CAAE,EACvDC,eAAiBJ,EAAyBK,MAAS,EAEnDC,aAAeC,EAAM,EAEtBC,aAAe,EACfC,kBAAoB,GACpBC,cACAC,UAEAC,YAAc,GAEtBC,aAAA,CACE,KAAKL,aAAe,KAAKT,aAAY,EAAK,GAC5C,CAEAe,oBAAkB,CACZ,KAAKF,cACP,KAAKA,YAAc,GAGnBG,WAAW,IAAK,CACV,KAAKC,UAAS,IAAO,IAAO,KAAKV,aAAaW,KAAI,CACxD,CAAC,EAEL,CAEAC,UAAQ,CACN,KAAKC,WAAU,CACjB,CAEAC,aAAW,CACL,KAAKV,eAAe,KAAKA,cAAcW,YAAW,CACxD,CAEAF,YAAU,CACR,KAAKR,UAAY,KAAKV,SAAQ,EAC1B,KAAKJ,GAAGyB,cACRC,SAASC,gBAGb,IAAMC,EAAkB,CAAEC,QAAS,GAAMC,SAAU,EAAI,EAEjDC,EAAoB,KAAK3B,SAAQ,EAAK,KAAKU,UAAYkB,OACvDC,EAAmBC,EAAUH,EAAmB,QAAQ,EAC3DI,KACCC,EAAU,EAAI,EACdC,EAAa,IAAK7B,OAAWoB,CAAe,EAC5CU,EAAI,IAAM,KAAKC,cAAa,CAAE,EAC9BC,EAAqB,CAACC,EAAIC,IAAOD,EAAGE,UAAYD,EAAGC,OAAO,EAC1DC,EAAK,CAAE,EAIX,KAAK/B,cAAgBoB,EAClBE,KACCU,EAAO,CAAC,CAAEF,QAAAA,CAAO,IAAO,KAAKG,gBAAgBH,CAAO,CAAC,EACrDE,EAAO,CAAC,CAAEF,QAAAA,EAASI,cAAAA,CAAa,IAAQJ,EAAUI,EAAiB,KAAKpC,YAAY,CAAC,EAEtFqC,UAAU,IAAK,CACd,KAAKvC,aAAaW,KAAI,CACxB,CAAC,EAEH,IAAMb,EAAiB,KAAKA,eAAc,EACtCA,GACFA,EACG4B,KAAKU,EAAOI,GAAKA,EAAEC,SAAW,CAAC,CAAC,EAChCF,UAAU,IAAM,KAAKjC,YAAc,EAAI,CAE9C,CAEQwB,eAAa,CACnB,MAAO,CAAEI,QAAS,KAAK7B,UAAUqC,UAAWJ,cAAe,KAAKK,iBAAgB,CAAE,CACpF,CAEQA,kBAAgB,CACtB,IAAMC,EAAgB,KAAKjD,SAAQ,EAAK,KAAKU,UAAUwC,aAAetB,OAAOuB,YAE7E,OAAO,KAAKzC,UAAU0C,aAAeH,CACvC,CAEQlC,WAAS,CACf,OAAO,KAAKiC,iBAAgB,EAAK,CACnC,CAEQN,gBAAiBH,EAAe,CACtC,IAAMc,EAAS,KAAK7C,kBAAoB+B,EAExC,YAAK/B,kBAAoB+B,EAClBc,CACT,KA/FW7D,wCAAAA,EAAyB,KAAzBA,sBAAAA,EAAyB8D,UAAA,CAAA,CAAA,GAAA,qBAAA,EAAA,CAAA,EAAAC,OAAA,CAAAzD,aAAA,CAAA,EAAA,cAAA,EAAAE,SAAA,CAAA,EAAA,UAAA,EAAAG,eAAA,CAAA,EAAA,gBAAA,CAAA,EAAAqD,QAAA,CAAAnD,aAAA,cAAA,CAAA,CAAA,GAAhC,IAAOb,EAAPiE,SAAOjE,CAAyB,GAAA",
  "names": ["InfiniteScrollerDirective", "peertubeRouter", "inject", "PeerTubeRouterService", "el", "ElementRef", "percentLimit", "input", "onItself", "transform", "booleanAttribute", "dataObservable", "undefined", "nearOfBottom", "output", "decimalLimit", "lastCurrentBottom", "scrollDownSub", "container", "checkScroll", "constructor", "ngAfterViewChecked", "setTimeout", "hasScroll", "emit", "ngOnInit", "initialize", "ngOnDestroy", "unsubscribe", "nativeElement", "document", "documentElement", "throttleOptions", "leading", "trailing", "scrollableElement", "window", "scrollObservable", "fromEvent", "pipe", "startWith", "throttleTime", "map", "getScrollInfo", "distinctUntilChanged", "o1", "o2", "current", "share", "filter", "isScrollingDown", "maximumScroll", "subscribe", "d", "length", "scrollTop", "getMaximumScroll", "elementHeight", "clientHeight", "innerHeight", "scrollHeight", "result", "selectors", "inputs", "outputs", "_InfiniteScrollerDirective"]
}

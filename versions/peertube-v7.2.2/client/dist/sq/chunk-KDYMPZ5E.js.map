{"version":3,"sources":["node_modules/@angular/cdk/fesm2022/shadow-dom-B0oHn41l.mjs","node_modules/@angular/cdk/fesm2022/id-generator-Dw_9dSDu.mjs"],"sourcesContent":["let shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n  if (shadowDomIsSupported == null) {\n    const head = typeof document !== 'undefined' ? document.head : null;\n    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n  }\n  return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null;\n    // Note that this should be caught by `_supportsShadowDom`, but some\n    // teams have been able to hit this code path on unsupported browsers.\n    if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n  return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n  let activeElement = typeof document !== 'undefined' && document ? document.activeElement : null;\n  while (activeElement && activeElement.shadowRoot) {\n    const newActiveElement = activeElement.shadowRoot.activeElement;\n    if (newActiveElement === activeElement) {\n      break;\n    } else {\n      activeElement = newActiveElement;\n    }\n  }\n  return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n  // If an event is bound outside the Shadow DOM, the `event.target` will\n  // point to the shadow root so we have to use `composedPath` instead.\n  return event.composedPath ? event.composedPath()[0] : event.target;\n}\nexport { _getEventTarget as _, _getShadowRoot as a, _supportsShadowDom as b, _getFocusedElementPierceShadowDom as c };\n","import * as i0 from '@angular/core';\nimport { inject, APP_ID, Injectable } from '@angular/core';\n\n/**\n * Keeps track of the ID count per prefix. This helps us make the IDs a bit more deterministic\n * like they were before the service was introduced. Note that ideally we wouldn't have to do\n * this, but there are some internal tests that rely on the IDs.\n */\nconst counters = {};\n/** Service that generates unique IDs for DOM nodes. */\nlet _IdGenerator = /*#__PURE__*/(() => {\n  class _IdGenerator {\n    _appId = inject(APP_ID);\n    /**\n     * Generates a unique ID with a specific prefix.\n     * @param prefix Prefix to add to the ID.\n     */\n    getId(prefix) {\n      // Omit the app ID if it's the default `ng`. Since the vast majority of pages have one\n      // Angular app on them, we can reduce the amount of breakages by not adding it.\n      if (this._appId !== 'ng') {\n        prefix += this._appId;\n      }\n      if (!counters.hasOwnProperty(prefix)) {\n        counters[prefix] = 0;\n      }\n      return `${prefix}${counters[prefix]++}`;\n    }\n    static ɵfac = function _IdGenerator_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _IdGenerator)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: _IdGenerator,\n      factory: _IdGenerator.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return _IdGenerator;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { _IdGenerator as _ };\n"],"mappings":"gGAAA,IAAIA,EAEJ,SAASC,GAAqB,CAC5B,GAAID,GAAwB,KAAM,CAChC,IAAME,EAAO,OAAO,SAAa,IAAc,SAAS,KAAO,KAC/DF,EAAuB,CAAC,EAAEE,IAASA,EAAK,kBAAoBA,EAAK,cACnE,CACA,OAAOF,CACT,CAEA,SAASG,EAAeC,EAAS,CAC/B,GAAIH,EAAmB,EAAG,CACxB,IAAMI,EAAWD,EAAQ,YAAcA,EAAQ,YAAY,EAAI,KAG/D,GAAI,OAAO,WAAe,KAAe,YAAcC,aAAoB,WACzE,OAAOA,CAEX,CACA,OAAO,IACT,CAKA,SAASC,GAAoC,CAC3C,IAAIC,EAAgB,OAAO,SAAa,KAAe,SAAW,SAAS,cAAgB,KAC3F,KAAOA,GAAiBA,EAAc,YAAY,CAChD,IAAMC,EAAmBD,EAAc,WAAW,cAClD,GAAIC,IAAqBD,EACvB,MAEAA,EAAgBC,CAEpB,CACA,OAAOD,CACT,CAEA,SAASE,EAAgBC,EAAO,CAG9B,OAAOA,EAAM,aAAeA,EAAM,aAAa,EAAE,CAAC,EAAIA,EAAM,MAC9D,CClCA,IAAMC,EAAW,CAAC,EAEdC,GAA6B,IAAM,CACrC,IAAMC,EAAN,MAAMA,CAAa,CACjB,OAASC,EAAOC,CAAM,EAKtB,MAAMC,EAAQ,CAGZ,OAAI,KAAK,SAAW,OAClBA,GAAU,KAAK,QAEZL,EAAS,eAAeK,CAAM,IACjCL,EAASK,CAAM,EAAI,GAEd,GAAGA,CAAM,GAAGL,EAASK,CAAM,GAAG,EACvC,CASF,EAREC,EAjBIJ,EAiBG,YAAO,SAA8BK,EAAmB,CAC7D,OAAO,IAAKA,GAAqBL,EACnC,GACAI,EApBIJ,EAoBG,aAA0BM,EAAmB,CAClD,MAAON,EACP,QAASA,EAAa,UACtB,WAAY,MACd,CAAC,GAxBH,IAAMD,EAANC,EA0BA,OAAOD,CACT,GAAG","names":["shadowDomIsSupported","_supportsShadowDom","head","_getShadowRoot","element","rootNode","_getFocusedElementPierceShadowDom","activeElement","newActiveElement","_getEventTarget","event","counters","_IdGenerator","__IdGenerator","inject","APP_ID","prefix","__publicField","__ngFactoryType__","ɵɵdefineInjectable"],"x_google_ignoreList":[0,1]}
{"version":3,"mappings":"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","names":["VideoCaptionService","authHttp","inject","HttpClient","serverService","ServerService","restExtractor","RestExtractor","confirmService","ConfirmService","listCaptions","videoId","videoPassword","headers","VideoPasswordService","buildVideoPasswordHeader","get","VideoService","BASE_VIDEO_URL","pipe","switchMap","captionsResult","getServerLocale","map","translations","c","data","language","label","peertubeTranslate","sortBy","catchError","res","handleError","removeCaption","delete","addCaption","captionfile","objectToFormData","put","updateCaptions","videoCaptions","obs","of","undefined","videoCaption","action","id","getCaptionContent","fileUrl","responseType","generateCaption","options","videos","from","concatMap","video","generateCaptionOfSpecificVideo","forceTranscription","toArray","reduce","p","success","alreadyHasCaptions","alreadyBeingTranscribed","err","body","post","error","code","ServerErrorCode","VIDEO_ALREADY_BEING_TRANSCRIBED","message","$localize","name","confirm","throwError","VIDEO_ALREADY_HAS_CAPTIONS","h","factory","Éµfac","_VideoCaptionService","F","a"],"ignoreList":[],"sources":["src/app/shared/shared-main/video-caption/video-caption.service.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http'\nimport { Injectable, inject } from '@angular/core'\nimport { ConfirmService, RestExtractor, ServerService } from '@app/core'\nimport { objectToFormData } from '@app/helpers'\nimport { peertubeTranslate, sortBy } from '@peertube/peertube-core-utils'\nimport { PeerTubeProblemDocument, ResultList, ServerErrorCode, Video, VideoCaption, VideoCaptionGenerate } from '@peertube/peertube-models'\nimport { Observable, from, of, throwError } from 'rxjs'\nimport { catchError, concatMap, map, switchMap, toArray } from 'rxjs/operators'\nimport { VideoPasswordService } from '../video/video-password.service'\nimport { VideoService } from '../video/video.service'\nimport { VideoCaptionEdit } from '../../../+videos-publish-manage/shared-manage/common/video-caption-edit.model'\n\n@Injectable()\nexport class VideoCaptionService {\n  private authHttp = inject(HttpClient)\n  private serverService = inject(ServerService)\n  private restExtractor = inject(RestExtractor)\n  private confirmService = inject(ConfirmService)\n\n  listCaptions (videoId: string, videoPassword?: string): Observable<ResultList<VideoCaption>> {\n    const headers = VideoPasswordService.buildVideoPasswordHeader(videoPassword)\n\n    return this.authHttp.get<ResultList<VideoCaption>>(`${VideoService.BASE_VIDEO_URL}/${videoId}/captions`, { headers })\n      .pipe(\n        switchMap(captionsResult => {\n          return this.serverService.getServerLocale()\n            .pipe(map(translations => ({ captionsResult, translations })))\n        }),\n        map(({ captionsResult, translations }) => {\n          for (const c of captionsResult.data) {\n            c.language.label = peertubeTranslate(c.language.label, translations)\n          }\n\n          return captionsResult\n        }),\n        map(captionsResult => {\n          sortBy(captionsResult.data, 'language', 'label')\n\n          return captionsResult\n        })\n      )\n      .pipe(catchError(res => this.restExtractor.handleError(res)))\n  }\n\n  removeCaption (videoId: number | string, language: string) {\n    return this.authHttp.delete(`${VideoService.BASE_VIDEO_URL}/${videoId}/captions/${language}`)\n      .pipe(catchError(res => this.restExtractor.handleError(res)))\n  }\n\n  addCaption (videoId: number | string, language: string, captionfile: File) {\n    const body = { captionfile }\n    const data = objectToFormData(body)\n\n    return this.authHttp.put(`${VideoService.BASE_VIDEO_URL}/${videoId}/captions/${language}`, data)\n      .pipe(catchError(res => this.restExtractor.handleError(res)))\n  }\n\n  updateCaptions (videoId: number | string, videoCaptions: VideoCaptionEdit[]) {\n    let obs: Observable<any> = of(undefined)\n\n    for (const videoCaption of videoCaptions) {\n      if (videoCaption.action === 'CREATE' || videoCaption.action === 'UPDATE') {\n        obs = obs.pipe(switchMap(() => this.addCaption(videoId, videoCaption.language.id, videoCaption.captionfile)))\n      } else if (videoCaption.action === 'REMOVE') {\n        obs = obs.pipe(switchMap(() => this.removeCaption(videoId, videoCaption.language.id)))\n      }\n    }\n\n    return obs\n  }\n\n  getCaptionContent ({ fileUrl }: Pick<VideoCaption, 'fileUrl'>) {\n    return this.authHttp.get(fileUrl, { responseType: 'text' })\n  }\n\n  // ---------------------------------------------------------------------------\n\n  generateCaption (options: {\n    videos: Video[]\n  }): Observable<{ success: number, alreadyHasCaptions: number, alreadyBeingTranscribed: number }> {\n    const { videos } = options\n\n    return from(videos)\n      .pipe(\n        concatMap(video => this.generateCaptionOfSpecificVideo({ video, forceTranscription: false })),\n        toArray(),\n        map(data => {\n          return data.reduce((p, c) => {\n            if (c === 'success') p.success += 1\n            if (c === 'already-has-captions') p.alreadyHasCaptions += 1\n            if (c === 'already-being-transcribed') p.alreadyBeingTranscribed += 1\n\n            return p\n          }, { success: 0, alreadyHasCaptions: 0, alreadyBeingTranscribed: 0 })\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  private generateCaptionOfSpecificVideo (options: {\n    video: Video\n    forceTranscription: boolean\n  }): Observable<'success' | 'already-has-captions' | 'already-being-transcribed'> {\n    const { video, forceTranscription } = options\n\n    const body: VideoCaptionGenerate = { forceTranscription }\n\n    return this.authHttp.post(`${VideoService.BASE_VIDEO_URL}/${video.id}/captions/generate`, body)\n      .pipe(\n        map(() => 'success' as 'success'),\n        catchError(err => {\n          const error: PeerTubeProblemDocument = err.error\n\n          if (error?.code === ServerErrorCode.VIDEO_ALREADY_BEING_TRANSCRIBED && !forceTranscription) {\n            const message = $localize`PeerTube considers video \"${video.name}\" is already being transcripted.` +\n              // eslint-disable-next-line max-len\n              $localize` If you think PeerTube is wrong (video in broken state after a crash etc.), you can force transcription on this video.` +\n              ` Do you still want to run transcription?`\n\n            return from(this.confirmService.confirm(message, $localize`Force transcription`))\n              .pipe(\n                switchMap(res => {\n                  if (res === false) return throwError(() => err)\n\n                  return this.generateCaptionOfSpecificVideo({ video, forceTranscription: true })\n                })\n              )\n          }\n\n          if (error?.code === ServerErrorCode.VIDEO_ALREADY_HAS_CAPTIONS) {\n            return of('already-has-captions' as 'already-has-captions')\n          }\n\n          if (error?.code === ServerErrorCode.VIDEO_ALREADY_BEING_TRANSCRIBED) {\n            return of('already-being-transcribed' as 'already-being-transcribed')\n          }\n\n          return throwError(() => err)\n        })\n      )\n  }\n}\n"]}
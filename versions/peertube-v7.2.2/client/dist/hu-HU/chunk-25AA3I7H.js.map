{
  "version": 3,
  "sources": ["src/app/shared/shared-forms/form-validator.service.ts", "src/app/shared/shared-forms/form-reactive.service.ts", "src/app/shared/shared-forms/form-reactive.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core'\nimport { AsyncValidatorFn, FormArray, FormBuilder, FormControl, FormGroup, ValidatorFn } from '@angular/forms'\nimport { objectKeysTyped } from '@peertube/peertube-core-utils'\nimport { BuildFormArgument, BuildFormDefaultValues } from '../form-validators/form-validator.model'\nimport { FormReactiveErrors, FormReactiveValidationMessages } from './form-reactive.service'\n\n@Injectable()\nexport class FormValidatorService {\n  private formBuilder = inject(FormBuilder)\n\n  internalBuildForm<T = any> (obj: BuildFormArgument, defaultValues: BuildFormDefaultValues = {}) {\n    const formErrors: FormReactiveErrors = {}\n    const validationMessages: FormReactiveValidationMessages = {}\n    const group: { [key: string]: any } = {}\n\n    for (const name of Object.keys(obj)) {\n      formErrors[name] = ''\n\n      const field = obj[name]\n      if (this.isRecursiveField(field)) {\n        const result = this.internalBuildForm(field as BuildFormArgument, defaultValues[name] as BuildFormDefaultValues)\n        group[name] = result.form\n        formErrors[name] = result.formErrors\n        validationMessages[name] = result.validationMessages\n\n        continue\n      }\n\n      if (field?.MESSAGES) validationMessages[name] = field.MESSAGES as { [name: string]: string }\n\n      const defaultValue = defaultValues[name] ?? ''\n\n      if (field?.VALIDATORS) group[name] = [ defaultValue, field.VALIDATORS ]\n      else group[name] = [ defaultValue ]\n    }\n\n    const form = this.formBuilder.group<T>(group as any)\n    return { form, formErrors, validationMessages }\n  }\n\n  updateFormGroup (\n    form: FormGroup,\n    formErrors: FormReactiveErrors,\n    validationMessages: FormReactiveValidationMessages,\n    formToBuild: BuildFormArgument,\n    defaultValues: BuildFormDefaultValues = {}\n  ) {\n    for (const name of objectKeysTyped(formToBuild)) {\n      const field = formToBuild[name]\n\n      if (this.isRecursiveField(field)) {\n        formErrors[name] = {}\n\n        this.updateFormGroup(\n          // FIXME: typings\n          (form as any)[name],\n          formErrors[name],\n          validationMessages[name] as FormReactiveValidationMessages,\n          formToBuild[name] as BuildFormArgument,\n          defaultValues[name] as BuildFormDefaultValues\n        )\n        continue\n      }\n\n      formErrors[name] = ''\n\n      if (field?.MESSAGES) validationMessages[name] = field.MESSAGES as { [name: string]: string }\n\n      const defaultValue = defaultValues[name] ?? ''\n\n      form.addControl(\n        name + '',\n        new FormControl(defaultValue, field?.VALIDATORS as ValidatorFn[], field?.ASYNC_VALIDATORS as AsyncValidatorFn[])\n      )\n    }\n  }\n\n  addControlInFormArray (options: {\n    formErrors: FormReactiveErrors\n    validationMessages: FormReactiveValidationMessages\n    formArray: FormArray\n    controlName: string\n    formToBuild: BuildFormArgument\n    defaultValues?: BuildFormDefaultValues\n  }) {\n    const { formArray, formErrors, validationMessages, controlName, formToBuild, defaultValues = {} } = options\n\n    const formGroup = new FormGroup({})\n    if (!formErrors[controlName]) formErrors[controlName] = [] as FormReactiveErrors[]\n    if (!validationMessages[controlName]) validationMessages[controlName] = []\n\n    const formArrayErrors = formErrors[controlName] as FormReactiveErrors[]\n    const formArrayValidationMessages = validationMessages[controlName] as FormReactiveValidationMessages[]\n\n    const totalControls = formArray.controls.length\n    formArrayErrors.push({})\n    formArrayValidationMessages.push({})\n\n    this.updateFormGroup(\n      formGroup,\n      formArrayErrors[totalControls],\n      formArrayValidationMessages[totalControls],\n      formToBuild,\n      defaultValues\n    )\n\n    formArray.push(formGroup)\n  }\n\n  removeControlFromFormArray (options: {\n    formErrors: FormReactiveErrors\n    validationMessages: FormReactiveValidationMessages\n    index: number\n    formArray: FormArray\n    controlName: string\n  }) {\n    const { formArray, formErrors, validationMessages, index, controlName } = options\n\n    const formArrayErrors = formErrors[controlName] as FormReactiveErrors[]\n    const formArrayValidationMessages = validationMessages[controlName] as FormReactiveValidationMessages[]\n\n    formArrayErrors.splice(index, 1)\n    formArrayValidationMessages.splice(index, 1)\n    formArray.removeAt(index)\n  }\n\n  updateTreeValidity (group: FormGroup | FormArray): void {\n    for (const key of Object.keys(group.controls)) {\n      // FIXME: typings\n      const abstractControl = (group.controls as any)[key] as FormControl\n\n      if (abstractControl instanceof FormGroup || abstractControl instanceof FormArray) {\n        this.updateTreeValidity(abstractControl)\n      } else {\n        abstractControl.updateValueAndValidity({ emitEvent: false })\n      }\n    }\n  }\n\n  private isRecursiveField (field: any) {\n    return field && typeof field === 'object' && !field.MESSAGES && !field.VALIDATORS\n  }\n}\n", "import { Injectable, inject } from '@angular/core'\nimport { AbstractControl, FormGroup, StatusChangeEvent } from '@angular/forms'\nimport { filter, firstValueFrom } from 'rxjs'\nimport { BuildFormArgument, BuildFormDefaultValues } from '../form-validators/form-validator.model'\nimport { FormValidatorService } from './form-validator.service'\n\nexport type FormReactiveErrors = { [id: string]: string | FormReactiveErrors | FormReactiveErrors[] }\nexport type FormReactiveValidationMessages = {\n  [id: string]: { [name: string]: string } | FormReactiveValidationMessages | FormReactiveValidationMessages[]\n}\n\n@Injectable()\nexport class FormReactiveService {\n  private formValidatorService = inject(FormValidatorService)\n\n  buildForm<T = any> (obj: BuildFormArgument, defaultValues: BuildFormDefaultValues = {}) {\n    const { formErrors, validationMessages, form } = this.formValidatorService.internalBuildForm<T>(obj, defaultValues)\n\n    form.events\n      .pipe(filter(e => e instanceof StatusChangeEvent))\n      .subscribe(() => this.onStatusChanged({ form, formErrors, validationMessages }))\n\n    return { form, formErrors, validationMessages }\n  }\n\n  waitPendingCheck (form: FormGroup) {\n    if (form.status !== 'PENDING') return\n\n    return firstValueFrom(form.events.pipe(filter(e => e instanceof StatusChangeEvent && e.status !== 'PENDING')))\n  }\n\n  markAllAsDirty (controlsArg: { [key: string]: AbstractControl }) {\n    const controls = controlsArg\n\n    for (const key of Object.keys(controls)) {\n      const control = controls[key]\n\n      if (control instanceof FormGroup) {\n        this.markAllAsDirty(control.controls)\n        continue\n      }\n\n      control.markAsDirty()\n    }\n  }\n\n  forceCheck (form: FormGroup, formErrors: any, validationMessages: FormReactiveValidationMessages) {\n    this.onStatusChanged({ form, formErrors, validationMessages, onlyDirty: false })\n  }\n\n  grabAllErrors (errorObjectArg: FormReactiveErrors | FormReactiveErrors[]) {\n    let acc: string[] = []\n\n    if (Array.isArray(errorObjectArg)) {\n      for (const errorObject of errorObjectArg) {\n        acc = acc.concat(this.grabAllErrors(errorObject))\n      }\n\n      return acc\n    }\n\n    for (const key of Object.keys(errorObjectArg)) {\n      const value = errorObjectArg[key]\n      if (!value) continue\n\n      if (typeof value === 'string') {\n        acc.push(value)\n      } else {\n        acc = acc.concat(this.grabAllErrors(value))\n      }\n    }\n\n    return acc\n  }\n\n  private onStatusChanged (options: {\n    form: FormGroup\n    formErrors: FormReactiveErrors\n    validationMessages: FormReactiveValidationMessages\n    onlyDirty?: boolean // default true\n  }) {\n    const { form, formErrors, validationMessages, onlyDirty = true } = options\n\n    for (const field of Object.keys(formErrors)) {\n      if (formErrors[field] && typeof formErrors[field] === 'object') {\n        this.onStatusChanged({\n          form: form.controls[field] as FormGroup,\n          formErrors: formErrors[field] as FormReactiveErrors,\n          validationMessages: validationMessages[field] as FormReactiveValidationMessages,\n          onlyDirty\n        })\n\n        continue\n      }\n\n      // clear previous error message (if any)\n      formErrors[field] = ''\n      const control = form.get(field)\n\n      if (!control || (onlyDirty && !control.dirty) || !control.enabled || !control.errors) continue\n\n      const staticMessages = validationMessages[field] as FormReactiveValidationMessages\n      for (const key of Object.keys(control.errors)) {\n        const formErrorValue = control.errors[key]\n\n        // Try to find error message in static validation messages first\n        // Then check if the validator returns a string that is the error\n        if (staticMessages[key]) formErrors[field] += staticMessages[key] + ' '\n        else if (typeof formErrorValue === 'string') formErrors[field] += control.errors[key]\n        else throw new Error('Form error value of ' + field + ' is invalid')\n      }\n    }\n  }\n}\n", "import { FormGroup } from '@angular/forms'\nimport { BuildFormArgument, BuildFormDefaultValues } from '../form-validators/form-validator.model'\nimport { FormReactiveService, FormReactiveValidationMessages } from './form-reactive.service'\n\nexport abstract class FormReactive {\n  protected abstract formReactiveService: FormReactiveService\n  protected formChanged = false\n\n  form: FormGroup\n  formErrors: any // To avoid casting in template because of string | FormReactiveErrors\n  validationMessages: FormReactiveValidationMessages\n\n  buildForm (obj: BuildFormArgument, defaultValues: BuildFormDefaultValues = {}) {\n    const { formErrors, validationMessages, form } = this.formReactiveService.buildForm(obj, defaultValues)\n\n    this.form = form\n    this.formErrors = formErrors\n    this.validationMessages = validationMessages\n  }\n\n  protected markAllAsDirty () {\n    return this.formReactiveService.markAllAsDirty(this.form.controls)\n  }\n\n  protected forceCheck () {\n    return this.formReactiveService.forceCheck(this.form, this.formErrors, this.validationMessages)\n  }\n}\n"],
  "mappings": "kLAOA,IAAaA,GAAoB,IAAA,CAA3B,IAAOA,EAAP,MAAOA,CAAoB,CACvBC,YAAcC,EAAOC,CAAW,EAExCC,kBAA4BC,EAAwBC,EAAwC,CAAA,EAAE,CAC5F,IAAMC,EAAiC,CAAA,EACjCC,EAAqD,CAAA,EACrDC,EAAgC,CAAA,EAEtC,QAAWC,KAAQC,OAAOC,KAAKP,CAAG,EAAG,CACnCE,EAAWG,CAAI,EAAI,GAEnB,IAAMG,EAAQR,EAAIK,CAAI,EACtB,GAAI,KAAKI,iBAAiBD,CAAK,EAAG,CAChC,IAAME,EAAS,KAAKX,kBAAkBS,EAA4BP,EAAcI,CAAI,CAA2B,EAC/GD,EAAMC,CAAI,EAAIK,EAAOC,KACrBT,EAAWG,CAAI,EAAIK,EAAOR,WAC1BC,EAAmBE,CAAI,EAAIK,EAAOP,mBAElC,QACF,CAEIK,GAAOI,WAAUT,EAAmBE,CAAI,EAAIG,EAAMI,UAEtD,IAAMC,EAAeZ,EAAcI,CAAI,GAAK,GAExCG,GAAOM,WAAYV,EAAMC,CAAI,EAAI,CAAEQ,EAAcL,EAAMM,UAAU,EAChEV,EAAMC,CAAI,EAAI,CAAEQ,CAAY,CACnC,CAGA,MAAO,CAAEF,KADI,KAAKf,YAAYQ,MAASA,CAAY,EACpCF,WAAAA,EAAYC,mBAAAA,CAAkB,CAC/C,CAEAY,gBACEJ,EACAT,EACAC,EACAa,EACAf,EAAwC,CAAA,EAAE,CAE1C,QAAWI,KAAQY,EAAgBD,CAAW,EAAG,CAC/C,IAAMR,EAAQQ,EAAYX,CAAI,EAE9B,GAAI,KAAKI,iBAAiBD,CAAK,EAAG,CAChCN,EAAWG,CAAI,EAAI,CAAA,EAEnB,KAAKU,gBAEFJ,EAAaN,CAAI,EAClBH,EAAWG,CAAI,EACfF,EAAmBE,CAAI,EACvBW,EAAYX,CAAI,EAChBJ,EAAcI,CAAI,CAA2B,EAE/C,QACF,CAEAH,EAAWG,CAAI,EAAI,GAEfG,GAAOI,WAAUT,EAAmBE,CAAI,EAAIG,EAAMI,UAEtD,IAAMC,EAAeZ,EAAcI,CAAI,GAAK,GAE5CM,EAAKO,WACHb,EAAO,GACP,IAAIc,EAAYN,EAAcL,GAAOM,WAA6BN,GAAOY,gBAAsC,CAAC,CAEpH,CACF,CAEAC,sBAAuBC,EAOtB,CACC,GAAM,CAAEC,UAAAA,EAAWrB,WAAAA,EAAYC,mBAAAA,EAAoBqB,YAAAA,EAAaR,YAAAA,EAAaf,cAAAA,EAAgB,CAAA,CAAE,EAAKqB,EAE9FG,EAAY,IAAIC,EAAU,CAAA,CAAE,EAC7BxB,EAAWsB,CAAW,IAAGtB,EAAWsB,CAAW,EAAI,CAAA,GACnDrB,EAAmBqB,CAAW,IAAGrB,EAAmBqB,CAAW,EAAI,CAAA,GAExE,IAAMG,EAAkBzB,EAAWsB,CAAW,EACxCI,EAA8BzB,EAAmBqB,CAAW,EAE5DK,EAAgBN,EAAUO,SAASC,OACzCJ,EAAgBK,KAAK,CAAA,CAAE,EACvBJ,EAA4BI,KAAK,CAAA,CAAE,EAEnC,KAAKjB,gBACHU,EACAE,EAAgBE,CAAa,EAC7BD,EAA4BC,CAAa,EACzCb,EACAf,CAAa,EAGfsB,EAAUS,KAAKP,CAAS,CAC1B,CAEAQ,2BAA4BX,EAM3B,CACC,GAAM,CAAEC,UAAAA,EAAWrB,WAAAA,EAAYC,mBAAAA,EAAoB+B,MAAAA,EAAOV,YAAAA,CAAW,EAAKF,EAEpEK,EAAkBzB,EAAWsB,CAAW,EACxCI,EAA8BzB,EAAmBqB,CAAW,EAElEG,EAAgBQ,OAAOD,EAAO,CAAC,EAC/BN,EAA4BO,OAAOD,EAAO,CAAC,EAC3CX,EAAUa,SAASF,CAAK,CAC1B,CAEAG,mBAAoBjC,EAA4B,CAC9C,QAAWkC,KAAOhC,OAAOC,KAAKH,EAAM0B,QAAQ,EAAG,CAE7C,IAAMS,EAAmBnC,EAAM0B,SAAiBQ,CAAG,EAE/CC,aAA2Bb,GAAaa,aAA2BC,EACrE,KAAKH,mBAAmBE,CAAe,EAEvCA,EAAgBE,uBAAuB,CAAEC,UAAW,EAAK,CAAE,CAE/D,CACF,CAEQjC,iBAAkBD,EAAU,CAClC,OAAOA,GAAS,OAAOA,GAAU,UAAY,CAACA,EAAMI,UAAY,CAACJ,EAAMM,UACzE,KAtIWnB,wCAAAA,EAAoB,KAApBA,wBAAAA,EAAoBgD,QAApBhD,EAAoBiD,SAAA,CAAA,GAA3B,IAAOjD,EAAPkD,SAAOlD,CAAoB,GAAA,ECKjC,IAAamD,GAAmB,IAAA,CAA1B,IAAOA,EAAP,MAAOA,CAAmB,CACtBC,qBAAuBC,EAAOC,CAAoB,EAE1DC,UAAoBC,EAAwBC,EAAwC,CAAA,EAAE,CACpF,GAAM,CAAEC,WAAAA,EAAYC,mBAAAA,EAAoBC,KAAAA,CAAI,EAAK,KAAKR,qBAAqBS,kBAAqBL,EAAKC,CAAa,EAElHG,OAAAA,EAAKE,OACFC,KAAKC,EAAOC,GAAKA,aAAaC,CAAiB,CAAC,EAChDC,UAAU,IAAM,KAAKC,gBAAgB,CAAER,KAAAA,EAAMF,WAAAA,EAAYC,mBAAAA,CAAkB,CAAE,CAAC,EAE1E,CAAEC,KAAAA,EAAMF,WAAAA,EAAYC,mBAAAA,CAAkB,CAC/C,CAEAU,iBAAkBT,EAAe,CAC/B,GAAIA,EAAKU,SAAW,UAEpB,OAAOC,EAAeX,EAAKE,OAAOC,KAAKC,EAAOC,GAAKA,aAAaC,GAAqBD,EAAEK,SAAW,SAAS,CAAC,CAAC,CAC/G,CAEAE,eAAgBC,EAA+C,CAC7D,IAAMC,EAAWD,EAEjB,QAAWE,KAAOC,OAAOC,KAAKH,CAAQ,EAAG,CACvC,IAAMI,EAAUJ,EAASC,CAAG,EAE5B,GAAIG,aAAmBC,EAAW,CAChC,KAAKP,eAAeM,EAAQJ,QAAQ,EACpC,QACF,CAEAI,EAAQE,YAAW,CACrB,CACF,CAEAC,WAAYrB,EAAiBF,EAAiBC,EAAkD,CAC9F,KAAKS,gBAAgB,CAAER,KAAAA,EAAMF,WAAAA,EAAYC,mBAAAA,EAAoBuB,UAAW,EAAK,CAAE,CACjF,CAEAC,cAAeC,EAAyD,CACtE,IAAIC,EAAgB,CAAA,EAEpB,GAAIC,MAAMC,QAAQH,CAAc,EAAG,CACjC,QAAWI,KAAeJ,EACxBC,EAAMA,EAAII,OAAO,KAAKN,cAAcK,CAAW,CAAC,EAGlD,OAAOH,CACT,CAEA,QAAWV,KAAOC,OAAOC,KAAKO,CAAc,EAAG,CAC7C,IAAMM,EAAQN,EAAeT,CAAG,EAC3Be,IAED,OAAOA,GAAU,SACnBL,EAAIM,KAAKD,CAAK,EAEdL,EAAMA,EAAII,OAAO,KAAKN,cAAcO,CAAK,CAAC,EAE9C,CAEA,OAAOL,CACT,CAEQjB,gBAAiBwB,EAKxB,CACC,GAAM,CAAEhC,KAAAA,EAAMF,WAAAA,EAAYC,mBAAAA,EAAoBuB,UAAAA,EAAY,EAAI,EAAKU,EAEnE,QAAWC,KAASjB,OAAOC,KAAKnB,CAAU,EAAG,CAC3C,GAAIA,EAAWmC,CAAK,GAAK,OAAOnC,EAAWmC,CAAK,GAAM,SAAU,CAC9D,KAAKzB,gBAAgB,CACnBR,KAAMA,EAAKc,SAASmB,CAAK,EACzBnC,WAAYA,EAAWmC,CAAK,EAC5BlC,mBAAoBA,EAAmBkC,CAAK,EAC5CX,UAAAA,EACD,EAED,QACF,CAGAxB,EAAWmC,CAAK,EAAI,GACpB,IAAMf,EAAUlB,EAAKkC,IAAID,CAAK,EAE9B,GAAI,CAACf,GAAYI,GAAa,CAACJ,EAAQiB,OAAU,CAACjB,EAAQkB,SAAW,CAAClB,EAAQmB,OAAQ,SAEtF,IAAMC,EAAiBvC,EAAmBkC,CAAK,EAC/C,QAAWlB,KAAOC,OAAOC,KAAKC,EAAQmB,MAAM,EAAG,CAC7C,IAAME,EAAiBrB,EAAQmB,OAAOtB,CAAG,EAIzC,GAAIuB,EAAevB,CAAG,EAAGjB,EAAWmC,CAAK,GAAKK,EAAevB,CAAG,EAAI,YAC3D,OAAOwB,GAAmB,SAAUzC,EAAWmC,CAAK,GAAKf,EAAQmB,OAAOtB,CAAG,MAC/E,OAAM,IAAIyB,MAAM,uBAAyBP,EAAQ,aAAa,CACrE,CACF,CACF,KApGW1C,wCAAAA,EAAmB,KAAnBA,wBAAAA,EAAmBkD,QAAnBlD,EAAmBmD,SAAA,CAAA,GAA1B,IAAOnD,EAAPoD,SAAOpD,CAAmB,GAAA,ECR1B,IAAgBqD,EAAhB,KAA4B,CAEtBC,YAAc,GAExBC,KACAC,WACAC,mBAEAC,UAAWC,EAAwBC,EAAwC,CAAA,EAAE,CAC3E,GAAM,CAAEJ,WAAAA,EAAYC,mBAAAA,EAAoBF,KAAAA,CAAI,EAAK,KAAKM,oBAAoBH,UAAUC,EAAKC,CAAa,EAEtG,KAAKL,KAAOA,EACZ,KAAKC,WAAaA,EAClB,KAAKC,mBAAqBA,CAC5B,CAEUK,gBAAc,CACtB,OAAO,KAAKD,oBAAoBC,eAAe,KAAKP,KAAKQ,QAAQ,CACnE,CAEUC,YAAU,CAClB,OAAO,KAAKH,oBAAoBG,WAAW,KAAKT,KAAM,KAAKC,WAAY,KAAKC,kBAAkB,CAChG",
  "names": ["FormValidatorService", "formBuilder", "inject", "FormBuilder", "internalBuildForm", "obj", "defaultValues", "formErrors", "validationMessages", "group", "name", "Object", "keys", "field", "isRecursiveField", "result", "form", "MESSAGES", "defaultValue", "VALIDATORS", "updateFormGroup", "formToBuild", "objectKeysTyped", "addControl", "FormControl", "ASYNC_VALIDATORS", "addControlInFormArray", "options", "formArray", "controlName", "formGroup", "FormGroup", "formArrayErrors", "formArrayValidationMessages", "totalControls", "controls", "length", "push", "removeControlFromFormArray", "index", "splice", "removeAt", "updateTreeValidity", "key", "abstractControl", "FormArray", "updateValueAndValidity", "emitEvent", "factory", "\u0275fac", "_FormValidatorService", "FormReactiveService", "formValidatorService", "inject", "FormValidatorService", "buildForm", "obj", "defaultValues", "formErrors", "validationMessages", "form", "internalBuildForm", "events", "pipe", "filter", "e", "StatusChangeEvent", "subscribe", "onStatusChanged", "waitPendingCheck", "status", "firstValueFrom", "markAllAsDirty", "controlsArg", "controls", "key", "Object", "keys", "control", "FormGroup", "markAsDirty", "forceCheck", "onlyDirty", "grabAllErrors", "errorObjectArg", "acc", "Array", "isArray", "errorObject", "concat", "value", "push", "options", "field", "get", "dirty", "enabled", "errors", "staticMessages", "formErrorValue", "Error", "factory", "\u0275fac", "_FormReactiveService", "FormReactive", "formChanged", "form", "formErrors", "validationMessages", "buildForm", "obj", "defaultValues", "formReactiveService", "markAllAsDirty", "controls", "forceCheck"]
}

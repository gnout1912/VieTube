{"version":3,"mappings":"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","names":["ɵɵelementContainerStart","ɵɵi18n","c","i","t","m","ɵɵadvance","ɵɵi18nExp","ctx_r0","instanceName","C","H","e","K","ɵɵtemplate","SignupLabelComponent_Conditional_0_Conditional_0_Template","SignupLabelComponent_Conditional_0_Conditional_1_Template","ɵɵconditional","requiresApproval","G","k","B","SignupLabelComponent_Conditional_1_Conditional_0_Template","SignupLabelComponent_Conditional_1_Conditional_1_Template","SignupLabelComponent","server","inject","ServerService","input","undefined","transform","booleanAttribute","withInstanceName","getHTMLConfig","instance","name","u","selectors","inputs","decls","vars","consts","i18n_0","a","n","$localize","SignupLabelComponent_Conditional_0_Template","SignupLabelComponent_Conditional_1_Template","ctx","encapsulation","_SignupLabelComponent","DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS","Typeahead","_letterKeyStream","Subject","_items","_selectedItemIndex","_pressedLetters","_skipPredicateFn","_selectedItem","selectedItem","constructor","initialItems","config","typeAheadInterval","debounceInterval","skipPredicate","setItems","_setupKeyHandler","destroy","complete","setCurrentSelectedItemIndex","index","items","handleKey","event","keyCode","key","length","next","toLocaleUpperCase","String","fromCharCode","isTyping","reset","pipe","tap","letter","push","debounceTime","filter","map","join","subscribe","inputString","item","getLabel","trim","indexOf","hasModifierKey","modifiers","some","modifier","altKey","shiftKey","ctrlKey","metaKey","ListKeyManager","_activeItemIndex","_activeItem","signal","_wrap","_typeaheadSubscription","Subscription","EMPTY","_itemChangesSubscription","_vertical","_horizontal","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_effectRef","_typeahead","disabled","injector","QueryList","changes","newItems","_itemsChanged","toArray","isSignal","effect","tabOut","change","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","withAllowedModifierKeys","keys","withTypeAhead","unsubscribe","_getItemsArray","setActiveItem","cancelTypeahead","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","onKeydown","isModifierAllowed","every","setNextItemActive","setPreviousItemActive","setFirstItemActive","setLastItemActive","targetIndex","_setActiveItemByIndex","itemsLength","preventDefault","activeItemIndex","activeItem","_setActiveItemByDelta","itemArray","set","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","newIndex","FocusKeyManager","_origin","setFocusOrigin","origin","focus","q","x","b","p","d"],"ignoreList":[2,3,4,5],"sources":["src/app/shared/shared-main/users/signup-label.component.html","src/app/shared/shared-main/users/signup-label.component.ts","node_modules/@angular/cdk/fesm2022/typeahead-9ZW4Dtsf.mjs","node_modules/@angular/cdk/fesm2022/keycodes.mjs","node_modules/@angular/cdk/fesm2022/list-key-manager-CyOIXo8P.mjs","node_modules/@angular/cdk/fesm2022/focus-key-manager-C1rAQJ5z.mjs"],"sourcesContent":["@if (withInstanceName()) {\n  @if (requiresApproval()) {\n    <ng-container i18n>Request an account on {{ instanceName }}</ng-container>\n  } @else {\n    <ng-container i18n>Create an account on {{ instanceName }}</ng-container>\n  }\n} @else {\n  @if (requiresApproval()) {\n    <ng-container i18n>Request an account</ng-container>\n  } @else {\n    <ng-container i18n>Create an account</ng-container>\n  }\n}\n","import { booleanAttribute, Component, inject, input } from '@angular/core'\nimport { ServerService } from '@app/core'\n\n@Component({\n  selector: 'my-signup-label',\n  templateUrl: './signup-label.component.html',\n  imports: []\n})\nexport class SignupLabelComponent {\n  private server = inject(ServerService)\n\n  readonly requiresApproval = input<boolean, unknown>(undefined, { transform: booleanAttribute })\n  readonly withInstanceName = input(false, { transform: booleanAttribute })\n\n  get instanceName () {\n    return this.server.getHTMLConfig().instance.name\n  }\n}\n","import { Subject } from 'rxjs';\nimport { tap, debounceTime, filter, map } from 'rxjs/operators';\nimport { A, Z, b as ZERO, N as NINE } from './keycodes-CpHkExLC.mjs';\nconst DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;\n/**\n * Selects items based on keyboard inputs. Implements the typeahead functionality of\n * `role=\"listbox\"` or `role=\"tree\"` and other related roles.\n */\nclass Typeahead {\n  _letterKeyStream = /*#__PURE__*/new Subject();\n  _items = [];\n  _selectedItemIndex = -1;\n  /** Buffer for the letters that the user has pressed */\n  _pressedLetters = [];\n  _skipPredicateFn;\n  _selectedItem = /*#__PURE__*/new Subject();\n  selectedItem = this._selectedItem;\n  constructor(initialItems, config) {\n    const typeAheadInterval = typeof config?.debounceInterval === 'number' ? config.debounceInterval : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;\n    if (config?.skipPredicate) {\n      this._skipPredicateFn = config.skipPredicate;\n    }\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && initialItems.length && initialItems.some(item => typeof item.getLabel !== 'function')) {\n      throw new Error('KeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n    this.setItems(initialItems);\n    this._setupKeyHandler(typeAheadInterval);\n  }\n  destroy() {\n    this._pressedLetters = [];\n    this._letterKeyStream.complete();\n    this._selectedItem.complete();\n  }\n  setCurrentSelectedItemIndex(index) {\n    this._selectedItemIndex = index;\n  }\n  setItems(items) {\n    this._items = items;\n  }\n  handleKey(event) {\n    const keyCode = event.keyCode;\n    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n    if (event.key && event.key.length === 1) {\n      this._letterKeyStream.next(event.key.toLocaleUpperCase());\n    } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {\n      this._letterKeyStream.next(String.fromCharCode(keyCode));\n    }\n  }\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping() {\n    return this._pressedLetters.length > 0;\n  }\n  /** Resets the currently stored sequence of typed letters. */\n  reset() {\n    this._pressedLetters = [];\n  }\n  _setupKeyHandler(typeAheadInterval) {\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._letterKeyStream.pipe(tap(letter => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join('').toLocaleUpperCase())).subscribe(inputString => {\n      // Start at 1 because we want to start searching at the item immediately\n      // following the current active item.\n      for (let i = 1; i < this._items.length + 1; i++) {\n        const index = (this._selectedItemIndex + i) % this._items.length;\n        const item = this._items[index];\n        if (!this._skipPredicateFn?.(item) && item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {\n          this._selectedItem.next(item);\n          break;\n        }\n      }\n      this._pressedLetters = [];\n    });\n  }\n}\nexport { Typeahead as T };\n","export { A, d as ALT, aX as APOSTROPHE, a1 as AT_SIGN, a2 as B, a_ as BACKSLASH, B as BACKSPACE, a3 as C, y as CAPS_LOCK, a$ as CLOSE_SQUARE_BRACKET, u as COMMA, as as CONTEXT_MENU, C as CONTROL, a4 as D, aV as DASH, i as DELETE, D as DOWN_ARROW, a5 as E, Y as EIGHT, E as END, c as ENTER, aU as EQUALS, g as ESCAPE, a6 as F, F as F1, r as F10, s as F11, t as F12, j as F2, k as F3, l as F4, m as F5, n as F6, o as F7, p as F8, q as F9, $ as FF_EQUALS, aL as FF_MINUS, aP as FF_MUTE, _ as FF_SEMICOLON, aQ as FF_VOLUME_DOWN, aS as FF_VOLUME_UP, aK as FIRST_MEDIA, V as FIVE, Q as FOUR, a7 as G, a8 as H, H as HOME, a9 as I, I as INSERT, aa as J, ab as K, ac as L, aR as LAST_MEDIA, L as LEFT_ARROW, ad as M, v as MAC_ENTER, M as MAC_META, aq as MAC_WK_CMD_LEFT, ar as MAC_WK_CMD_RIGHT, e as META, aM as MUTE, ae as N, N as NINE, aH as NUMPAD_DIVIDE, aB as NUMPAD_EIGHT, ay as NUMPAD_FIVE, ax as NUMPAD_FOUR, aF as NUMPAD_MINUS, aD as NUMPAD_MULTIPLY, aC as NUMPAD_NINE, au as NUMPAD_ONE, aG as NUMPAD_PERIOD, aE as NUMPAD_PLUS, aA as NUMPAD_SEVEN, az as NUMPAD_SIX, aw as NUMPAD_THREE, av as NUMPAD_TWO, at as NUMPAD_ZERO, w as NUM_CENTER, aI as NUM_LOCK, af as O, O as ONE, aZ as OPEN_SQUARE_BRACKET, ag as P, P as PAGE_DOWN, a as PAGE_UP, x as PAUSE, h as PERIOD, z as PLUS_SIGN, G as PRINT_SCREEN, ah as Q, a0 as QUESTION_MARK, ai as R, R as RIGHT_ARROW, aj as S, aJ as SCROLL_LOCK, aT as SEMICOLON, X as SEVEN, f as SHIFT, b0 as SINGLE_QUOTE, W as SIX, aW as SLASH, S as SPACE, ak as T, T as TAB, K as THREE, aY as TILDE, J as TWO, al as U, U as UP_ARROW, am as V, aN as VOLUME_DOWN, aO as VOLUME_UP, an as W, ao as X, ap as Y, Z, b as ZERO } from './keycodes-CpHkExLC.mjs';\n\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n  if (modifiers.length) {\n    return modifiers.some(modifier => event[modifier]);\n  }\n  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\nexport { hasModifierKey };\n","import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { T as Typeahead } from './typeahead-9ZW4Dtsf.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { P as PAGE_DOWN, a as PAGE_UP, E as END, H as HOME, L as LEFT_ARROW, R as RIGHT_ARROW, U as UP_ARROW, D as DOWN_ARROW, T as TAB } from './keycodes-CpHkExLC.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n  _items;\n  _activeItemIndex = -1;\n  _activeItem = /*#__PURE__*/signal(null);\n  _wrap = false;\n  _typeaheadSubscription = Subscription.EMPTY;\n  _itemChangesSubscription;\n  _vertical = true;\n  _horizontal;\n  _allowedModifierKeys = [];\n  _homeAndEnd = false;\n  _pageUpAndDown = {\n    enabled: false,\n    delta: 10\n  };\n  _effectRef;\n  _typeahead;\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  _skipPredicateFn = item => item.disabled;\n  constructor(_items, injector) {\n    this._items = _items;\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe(newItems => this._itemsChanged(newItems.toArray()));\n    } else if (isSignal(_items)) {\n      if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('ListKeyManager constructed with a signal must receive an injector');\n      }\n      this._effectRef = effect(() => this._itemsChanged(_items()), {\n        injector\n      });\n    }\n  }\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  tabOut = /*#__PURE__*/new Subject();\n  /** Stream that emits whenever the active item of the list manager changes. */\n  change = /*#__PURE__*/new Subject();\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate) {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true) {\n    this._wrap = shouldWrap;\n    return this;\n  }\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled = true) {\n    this._vertical = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction) {\n    this._horizontal = direction;\n    return this;\n  }\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys) {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval = 200) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const items = this._getItemsArray();\n      if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n        throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n      }\n    }\n    this._typeaheadSubscription.unsubscribe();\n    const items = this._getItemsArray();\n    this._typeahead = new Typeahead(items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item)\n    });\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.setActiveItem(item);\n    });\n    return this;\n  }\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead() {\n    this._typeahead?.reset();\n    return this;\n  }\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled = true) {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled = true, delta = 10) {\n    this._pageUpAndDown = {\n      enabled,\n      delta\n    };\n    return this;\n  }\n  setActiveItem(item) {\n    const previousActiveItem = this._activeItem();\n    this.updateActiveItem(item);\n    if (this._activeItem() !== previousActiveItem) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event) {\n    const keyCode = event.keyCode;\n    const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          this._typeahead?.handleKey(event);\n        }\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n  /** Index of the currently active item. */\n  get activeItemIndex() {\n    return this._activeItemIndex;\n  }\n  /** The active item. */\n  get activeItem() {\n    return this._activeItem();\n  }\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping() {\n    return !!this._typeahead && this._typeahead.isTyping();\n  }\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive() {\n    this._setActiveItemByIndex(0, 1);\n  }\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive() {\n    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n  }\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive() {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive() {\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);\n  }\n  updateActiveItem(item) {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem.set(activeItem == null ? null : activeItem);\n    this._activeItemIndex = index;\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n  }\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._effectRef?.destroy();\n    this._typeahead?.destroy();\n    this.tabOut.complete();\n    this.change.complete();\n  }\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  _setActiveItemByDelta(delta) {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  _setActiveInWrapMode(delta) {\n    const items = this._getItemsArray();\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n      const item = items[index];\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  _setActiveInDefaultMode(delta) {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  _setActiveItemByIndex(index, fallbackDelta) {\n    const items = this._getItemsArray();\n    if (!items[index]) {\n      return;\n    }\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n      if (!items[index]) {\n        return;\n      }\n    }\n    this.setActiveItem(index);\n  }\n  /** Returns the items as an array. */\n  _getItemsArray() {\n    if (isSignal(this._items)) {\n      return this._items();\n    }\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n  /** Callback for when the items have changed. */\n  _itemsChanged(newItems) {\n    this._typeahead?.setItems(newItems);\n    const activeItem = this._activeItem();\n    if (activeItem) {\n      const newIndex = newItems.indexOf(activeItem);\n      if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n        this._activeItemIndex = newIndex;\n        this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n      }\n    }\n  }\n}\nexport { ListKeyManager as L };\n","import { L as ListKeyManager } from './list-key-manager-CyOIXo8P.mjs';\nclass FocusKeyManager extends ListKeyManager {\n  _origin = 'program';\n  /**\n   * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n   * @param origin Focus origin to be used when focusing items.\n   */\n  setFocusOrigin(origin) {\n    this._origin = origin;\n    return this;\n  }\n  setActiveItem(item) {\n    super.setActiveItem(item);\n    if (this.activeItem) {\n      this.activeItem.focus(this._origin);\n    }\n  }\n}\nexport { FocusKeyManager as F };\n"]}
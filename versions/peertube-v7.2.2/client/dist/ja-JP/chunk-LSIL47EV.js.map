{
  "version": 3,
  "sources": ["src/app/shared/shared-user-subscription/user-subscription.service.ts"],
  "sourcesContent": ["import debug from 'debug'\nimport { merge, Observable, of, ReplaySubject, Subject } from 'rxjs'\nimport { catchError, filter, map, switchMap, tap } from 'rxjs/operators'\nimport { HttpClient, HttpParams } from '@angular/common/http'\nimport { Injectable, inject } from '@angular/core'\nimport { ComponentPaginationLight, RestExtractor, RestService } from '@app/core'\nimport { buildBulkObservable } from '@app/helpers'\nimport { ActorFollow, ResultList, VideoChannel as VideoChannelServer, VideoSortField } from '@peertube/peertube-models'\nimport { environment } from '../../../environments/environment'\nimport { Video } from '../shared-main/video/video.model'\nimport { VideoChannel } from '../shared-main/channel/video-channel.model'\nimport { VideoService } from '../shared-main/video/video.service'\nimport { VideoChannelService } from '../shared-main/channel/video-channel.service'\n\nconst debugLogger = debug('peertube:subscriptions:UserSubscriptionService')\n\ntype SubscriptionExistResult = { [uri: string]: boolean }\ntype SubscriptionExistResultObservable = { [uri: string]: Observable<boolean> }\n\n@Injectable()\nexport class UserSubscriptionService {\n  private authHttp = inject(HttpClient)\n  private restExtractor = inject(RestExtractor)\n  private videoService = inject(VideoService)\n  private restService = inject(RestService)\n\n  static BASE_USER_SUBSCRIPTIONS_URL = environment.apiUrl + '/api/v1/users/me/subscriptions'\n  static BASE_VIDEO_CHANNELS_URL = environment.apiUrl + '/api/v1/video-channels'\n  static BASE_ACCOUNTS_URL = environment.apiUrl + '/api/v1/accounts'\n\n  // Use a replay subject because we \"next\" a value before subscribing\n  private existsSubject = new ReplaySubject<string>(1)\n  private readonly existsObservable: Observable<SubscriptionExistResult>\n\n  private myAccountSubscriptionCache: SubscriptionExistResult = {}\n  private myAccountSubscriptionCacheObservable: SubscriptionExistResultObservable = {}\n  private myAccountSubscriptionCacheSubject = new Subject<SubscriptionExistResult>()\n\n  constructor () {\n    this.existsObservable = merge(\n      buildBulkObservable({\n        time: 200,\n        notifierObservable: this.existsSubject,\n        bulkGet: this.doSubscriptionsExist.bind(this)\n      }).pipe(map(r => r.response)),\n      this.myAccountSubscriptionCacheSubject\n    )\n  }\n\n  listFollowers (parameters: {\n    pagination: ComponentPaginationLight\n    nameWithHost: string\n    search?: string\n  }) {\n    const { pagination, nameWithHost, search } = parameters\n\n    let url = `${UserSubscriptionService.BASE_ACCOUNTS_URL}/${nameWithHost}/followers`\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, this.restService.componentToRestPagination(pagination), '-createdAt')\n\n    if (search) {\n      const filters = this.restService.parseQueryStringFilter(search, {\n        channel: {\n          prefix: 'channel:'\n        }\n      })\n\n      if (filters.channel) {\n        url = `${UserSubscriptionService.BASE_VIDEO_CHANNELS_URL}/${filters.channel}/followers`\n      }\n\n      params = this.restService.addObjectParams(params, { search: filters.search })\n    }\n\n    return this.authHttp\n      .get<ResultList<ActorFollow>>(url, { params })\n      .pipe(\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  getUserSubscriptionVideos (parameters: {\n    videoPagination: ComponentPaginationLight\n    sort: VideoSortField\n    skipCount?: boolean\n  }): Observable<ResultList<Video>> {\n    const { videoPagination, sort, skipCount } = parameters\n    const pagination = this.restService.componentToRestPagination(videoPagination)\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, pagination, sort)\n\n    if (skipCount) params = params.set('skipCount', skipCount + '')\n\n    return this.authHttp\n      .get<ResultList<Video>>(UserSubscriptionService.BASE_USER_SUBSCRIPTIONS_URL + '/videos', { params })\n      .pipe(\n        switchMap(res => this.videoService.extractVideos(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  /**\n   * Subscription part\n   */\n\n  deleteSubscription (nameWithHost: string) {\n    const url = UserSubscriptionService.BASE_USER_SUBSCRIPTIONS_URL + '/' + nameWithHost\n\n    return this.authHttp.delete(url)\n      .pipe(\n        tap(() => {\n          this.myAccountSubscriptionCache[nameWithHost] = false\n\n          this.myAccountSubscriptionCacheSubject.next(this.myAccountSubscriptionCache)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  addSubscription (nameWithHost: string) {\n    const url = UserSubscriptionService.BASE_USER_SUBSCRIPTIONS_URL\n\n    const body = { uri: nameWithHost }\n    return this.authHttp.post(url, body)\n      .pipe(\n        tap(() => {\n          this.myAccountSubscriptionCache[nameWithHost] = true\n\n          this.myAccountSubscriptionCacheSubject.next(this.myAccountSubscriptionCache)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  listSubscriptions (parameters: {\n    pagination: ComponentPaginationLight\n    search: string\n  }): Observable<ResultList<VideoChannel>> {\n    const { pagination, search } = parameters\n    const url = UserSubscriptionService.BASE_USER_SUBSCRIPTIONS_URL\n\n    const restPagination = this.restService.componentToRestPagination(pagination)\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, restPagination)\n    if (search) params = params.append('search', search)\n\n    return this.authHttp.get<ResultList<VideoChannelServer>>(url, { params })\n      .pipe(\n        map(res => VideoChannelService.extractVideoChannels(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  /**\n   * SubscriptionExist part\n   */\n\n  listenToMyAccountSubscriptionCacheSubject () {\n    return this.myAccountSubscriptionCacheSubject.asObservable()\n  }\n\n  listenToSubscriptionCacheChange (nameWithHost: string) {\n    if (nameWithHost in this.myAccountSubscriptionCacheObservable) {\n      return this.myAccountSubscriptionCacheObservable[nameWithHost]\n    }\n\n    const obs = this.existsObservable\n      .pipe(\n        filter(existsResult => existsResult[nameWithHost] !== undefined),\n        map(existsResult => existsResult[nameWithHost])\n      )\n\n    this.myAccountSubscriptionCacheObservable[nameWithHost] = obs\n    return obs\n  }\n\n  doesSubscriptionExist (nameWithHost: string) {\n    debugLogger('Running subscription check for ' + nameWithHost)\n\n    if (nameWithHost in this.myAccountSubscriptionCache) {\n      debugLogger('Found cache for ' + nameWithHost)\n\n      return of(this.myAccountSubscriptionCache[nameWithHost])\n    }\n\n    this.existsSubject.next(nameWithHost)\n\n    debugLogger('Fetching from network for ' + nameWithHost)\n    return this.existsObservable.pipe(\n      filter(existsResult => existsResult[nameWithHost] !== undefined),\n      map(existsResult => existsResult[nameWithHost]),\n      tap(result => this.myAccountSubscriptionCache[nameWithHost] = result)\n    )\n  }\n\n  private doSubscriptionsExist (uris: string[]): Observable<SubscriptionExistResult> {\n    const url = UserSubscriptionService.BASE_USER_SUBSCRIPTIONS_URL + '/exist'\n    let params = new HttpParams()\n\n    params = this.restService.addObjectParams(params, { uris })\n\n    return this.authHttp.get<SubscriptionExistResult>(url, { params })\n      .pipe(\n        tap(res => {\n          this.myAccountSubscriptionCache = {\n            ...this.myAccountSubscriptionCache,\n            ...res\n          }\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_debug", "debugLogger", "debug", "UserSubscriptionService", "authHttp", "inject", "HttpClient", "restExtractor", "RestExtractor", "videoService", "VideoService", "restService", "RestService", "existsSubject", "ReplaySubject", "existsObservable", "myAccountSubscriptionCache", "myAccountSubscriptionCacheObservable", "myAccountSubscriptionCacheSubject", "Subject", "constructor", "merge", "buildBulkObservable", "time", "notifierObservable", "bulkGet", "doSubscriptionsExist", "bind", "pipe", "map", "r", "response", "listFollowers", "parameters", "pagination", "nameWithHost", "search", "url", "BASE_ACCOUNTS_URL", "params", "HttpParams", "addRestGetParams", "componentToRestPagination", "filters", "parseQueryStringFilter", "channel", "prefix", "BASE_VIDEO_CHANNELS_URL", "addObjectParams", "get", "catchError", "err", "handleError", "getUserSubscriptionVideos", "videoPagination", "sort", "skipCount", "set", "BASE_USER_SUBSCRIPTIONS_URL", "switchMap", "res", "extractVideos", "deleteSubscription", "delete", "tap", "next", "addSubscription", "body", "uri", "post", "listSubscriptions", "restPagination", "append", "VideoChannelService", "extractVideoChannels", "listenToMyAccountSubscriptionCacheSubject", "asObservable", "listenToSubscriptionCacheChange", "obs", "filter", "existsResult", "undefined", "doesSubscriptionExist", "of", "result", "uris", "__spreadValues", "__publicField", "environment", "apiUrl", "factory", "\u0275fac", "_UserSubscriptionService"]
}

{"version":3,"mappings":"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","names":["createXhr","XMLHttpRequest","releaseXhr","_xhr","UploadxAjax","buildXhr","constructor","request","method","data","headers","url","responseType","signal","onUploadProgress","timeout","withCredentials","validateStatus","status","Promise","resolve","reject","xhr","abortListener","P","readyState","DONE","abort","addEventListener","once","open","Object","keys","forEach","key","setRequestHeader","String","upload","onprogress","onerror","ontimeout","onabort","evt","removeEventListener","error","type","onload","response","getResponseBody","getResponseHeaders","send","getAllResponseHeaders","split","reduce","current","name","value","toLowerCase","body","responseText","JSON","parse","UPLOADX_AJAX","InjectionToken","factory","providedIn","Canceler","onCancel","cancel","KiB","_DynamicChunk","scale","throughput","elapsedTime","size","minChunkTime","Math","min","maxSize","maxChunkTime","max","minSize","__publicField","Number","MAX_SAFE_INTEGER","DynamicChunk","safeMatch","base","re","match","resolveUrl","indexOf","unfunc","ref","Function","pick","ce","obj","props","result","isNumber","x","createHash","str","hash","len","length","i","charCodeAt","isBrowser","window","navigator","includes","onLine","isIOS","test","userAgent","osVersion","m","exec","compareVersions","a","b","localeCompare","numeric","isBadIOS","iosOverride","chunkSize","retryConfig","shouldRetry","IdService","_IdService","generateId","uploader","print","stringify","__spreadProps","__spreadValues","metadata","endpoint","toString","__ngFactoryType__","ɵɵdefineInjectable","token","ɵfac","ErrorType","NotFound","Auth","Retryable","Fatal","defaultRetryConfig","maxAttempts","shouldRestartCodes","authErrorCodes","shouldRetryCodes","code","minDelay","maxDelay","onBusyDelay","keepPartial","statusCode","RetryHandler","attempts","config","observedValue","configOptions","assign","kind","wait","time","ms","jitter","floor","random","id","clearTimeout","setTimeout","observe","HOUR","Store","prefix","ttl","set","localStorage","setItem","Date","now","get","item","getItem","expires","delete","removeItem","clear","maxAgeHours","filter","store","isLocalStorageAvailable","Map","getValue","actionToStatusMap","pause","update","Uploader","file","options","stateChange","ajax","uploadId","responseStatus","responseHeaders","progress","remaining","speed","offset","retry","canceler","abortController","AbortController","_authorize","_prerequest","_token","_eventsCount","mimeType","lastModified","maxChunkSize","prerequest","req","authorize","configure","_url","_status","s","cleanup","cancelAndSendState","updateAndSendState","action","__async","updateToken","getFileUrl","sendFileContent","getOffset","getRetryAfterFromBackend","e","Error","console","requestOptions","aborted","skipAuthorization","ajaxRequestConfig","onProgress","_data","catch","getValueFromResponse","getChunk","start","end","slice","then","throttle","startTime","loaded","uploaded","toFixed","UploaderX","getOffsetFromResponse","location","range","getRangeEnd","parseInt","defaultOptions","autoUpload","concurrency","uploaderClass","Authorization","storeIncompleteHours","UPLOADX_FACTORY_OPTIONS","UPLOADX_OPTIONS","UPLOAD_STATE_KEYS","DUE_TIME","UploadxService","_UploadxService","queue","eventsStream","Subject","subs","ngZone","inject","NgZone","idService","optional","defaults","push","fromEvent","subscribe","control","events","asObservable","init","connect","pipe","map","debounceTime","disconnect","state","ngOnDestroy","sub","unsubscribe","handleFiles","files","instanceOptions","Array","from","addUploaderInstance","activeUploadsCount","run","next","runOutsideAngular","processQueue","ze","n","te","ɵɵelementStart","ɵɵelement","ɵɵlistener","ɵɵrestoreView","_r1","ctx_r1","ɵɵnextContext","ɵɵresetView","emit","ɵɵelementEnd","S","ɵɵadvance","ɵɵproperty","Fe","ɵɵi18n","ɵɵtext","ɵɵtextInterpolate1","Me","ɵɵtemplate","UploadProgressComponent_Conditional_0_Conditional_0_Template","UploadProgressComponent_Conditional_0_Conditional_1_Template","ɵɵconditional","enableRetryAfterError","Ne","uploadPercents","getUploadingLabel","UploadProgressComponent","isUploading","input","undefined","uploadedLabel","output","$localize","u","selectors","inputs","outputs","decls","vars","consts","i18n_0","UploadProgressComponent_Conditional_0_Template","UploadProgressComponent_Conditional_1_Template","ctx","dependencies","CommonModule","ProgressBarComponent","AlertComponent","styles","_UploadProgressComponent","de","$","at","c","mt","d"],"ignoreList":[0],"sources":["node_modules/ngx-uploadx/fesm2022/ngx-uploadx.mjs","src/app/shared/standalone-upload/upload-progress.component.html","src/app/shared/standalone-upload/upload-progress.component.ts"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, inject, NgZone, EventEmitter, Directive, Input, Output, HostListener, HostBinding, ContentChild, NgModule } from '@angular/core';\nimport { map, debounceTime, takeWhile } from 'rxjs/operators';\nimport { Subject, fromEvent } from 'rxjs';\nfunction createXhr() {\n  return new XMLHttpRequest();\n}\nfunction releaseXhr(_xhr) {\n  _xhr = null;\n}\nclass UploadxAjax {\n  buildXhr;\n  constructor(buildXhr) {\n    this.buildXhr = buildXhr;\n  }\n  request = ({\n    method = 'GET',\n    data = null,\n    headers = {},\n    url,\n    responseType,\n    signal,\n    onUploadProgress,\n    timeout = 0,\n    withCredentials = false,\n    validateStatus = status => status < 400 && status >= 200\n  }) => {\n    return new Promise((resolve, reject) => {\n      const xhr = this.buildXhr();\n      const abortListener = () => xhr && xhr.readyState !== xhr.DONE && xhr.abort();\n      signal?.addEventListener('abort', abortListener, {\n        once: true\n      });\n      xhr.open(method, url, true);\n      xhr.timeout = timeout;\n      withCredentials && (xhr.withCredentials = true);\n      if (responseType && responseType !== 'json') {\n        xhr.responseType = responseType;\n      }\n      Object.keys(headers).forEach(key => xhr.setRequestHeader(key, String(headers[key])));\n      xhr.upload.onprogress = onUploadProgress || null;\n      xhr.onerror = xhr.ontimeout = xhr.onabort = evt => {\n        releaseXhr(xhr);\n        signal?.removeEventListener('abort', abortListener);\n        return reject({\n          error: evt.type,\n          url,\n          method\n        });\n      };\n      xhr.onload = () => {\n        const response = {\n          data: this.getResponseBody(xhr, responseType),\n          status: xhr.status,\n          headers: this.getResponseHeaders(xhr)\n        };\n        releaseXhr(xhr);\n        signal?.removeEventListener('abort', abortListener);\n        return validateStatus(response.status) ? resolve(response) : reject(response);\n      };\n      xhr.send(data);\n    });\n  };\n  getResponseHeaders(xhr) {\n    const rows = xhr.getAllResponseHeaders().split(/[\\r\\n]+/);\n    return rows.reduce((headers, current) => {\n      const [name, value] = current.split(': ');\n      name && (headers[name.toLowerCase()] = value);\n      return headers;\n    }, {});\n  }\n  getResponseBody(xhr, responseType) {\n    let body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;\n    if (responseType === 'json' && body && typeof body === 'string') {\n      try {\n        body = JSON.parse(body);\n      } catch {}\n    }\n    return body;\n  }\n}\nconst UPLOADX_AJAX = new InjectionToken('uploadx.ajax', {\n  factory: () => new UploadxAjax(createXhr),\n  providedIn: 'root'\n});\n\n/**\n * Allows canceling some operation by calling cancel().\n * onCancel callback can be used to execute cleanup logic when cancel is called.\n */\nclass Canceler {\n  /**\n   * Callback function to execute cleanup logic when cancel() is called\n   */\n  onCancel = () => {};\n  /**\n   * Cancels the operation.\n   */\n  cancel() {\n    this.onCancel();\n    this.onCancel = () => {};\n  }\n}\nconst KiB = 1024;\n/**\n * Adaptive chunk size\n */\nclass DynamicChunk {\n  /** Maximum chunk size in bytes */\n  static maxSize = Number.MAX_SAFE_INTEGER;\n  /** Minimum chunk size in bytes */\n  static minSize = 256 * KiB;\n  /** Initial chunk size in bytes */\n  static size = 4 * (256 * KiB);\n  static minChunkTime = 8;\n  static maxChunkTime = 24;\n  /**\n   * Scales the chunk size based on the throughput.\n   * If the elapsed time to upload a chunk is less than the min time, increase the chunk size.\n   * If the elapsed time is more than the max time, decrease the chunk size.\n   * Keeps the chunk size within the min and max limits.\n   * @param throughput - represents the upload rate in bytes/sec.\n   */\n  static scale(throughput) {\n    const elapsedTime = DynamicChunk.size / throughput;\n    if (elapsedTime < DynamicChunk.minChunkTime) {\n      DynamicChunk.size = Math.min(DynamicChunk.maxSize, DynamicChunk.size * 2);\n    }\n    if (elapsedTime > DynamicChunk.maxChunkTime) {\n      DynamicChunk.size = Math.max(DynamicChunk.minSize, DynamicChunk.size / 2);\n    }\n    return DynamicChunk.size;\n  }\n}\nfunction safeMatch(base, re) {\n  return (base.match(re) || [''])[0];\n}\nfunction resolveUrl(url, base) {\n  if (url.indexOf('https://') * url.indexOf('http://') === 0) return url;\n  if (url.indexOf('//') === 0) return safeMatch(base, /^(https?:)/) + url;\n  if (url.indexOf('/') === 0) return safeMatch(base, /^(?:https?:)?(?:\\/\\/)?([^\\/?]+)/) + url;\n  return safeMatch(base, /^(?:https?:)?(?:\\/\\/)?([^\\/?]+)?(.*\\/)/) + url;\n}\n/**\n * Unwraps a value if it is a function, otherwise returns the value directly.\n * Useful for allowing values to optionally be specified as functions.\n */\nfunction unfunc(value, ref) {\n  return value instanceof Function ? value(ref) : value;\n}\nconst pick = (obj, props) => {\n  const result = {};\n  props.forEach(key => result[key] = obj[key]);\n  return result;\n};\nfunction isNumber(x) {\n  return x === Number(x);\n}\n/**\n * 32-bit FNV-1a hash function\n */\nfunction createHash(str) {\n  let hash = 2166136261;\n  const len = str.length;\n  for (let i = 0; i < len; i++) {\n    hash ^= str.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return hash >>> 0;\n}\n/**\n * Utility functions for base64 encoding and decoding strings and objects.\n */\nconst b64 = {\n  encode: str => btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(Number.parseInt(p1, 16)))),\n  decode: str => decodeURIComponent(atob(str).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join('')),\n  serialize: obj => Object.keys(obj).map(key => [key, b64.encode(String(obj[key]))].filter(Boolean).join(' ')).toString(),\n  parse: encoded => {\n    const kvPairs = encoded.split(',').map(kv => kv.split(' '));\n    const decoded = {};\n    for (const [key, value] of kvPairs) {\n      if (key) decoded[key] = value ? b64.decode(value) : '';\n    }\n    return decoded;\n  }\n};\nfunction isBrowser() {\n  return ![typeof window, typeof navigator].includes('undefined');\n}\nfunction onLine() {\n  return isBrowser() ? navigator.onLine : true;\n}\nfunction isIOS() {\n  return isBrowser() && /iPad|iPhone/.test(navigator.userAgent);\n}\nfunction osVersion() {\n  const m = /OS (\\d+)_(\\d+)_?(\\d+)?/.exec(navigator.userAgent);\n  if (m?.length) return m[1] + '.' + m[2] + '.' + m[3] || '0';\n  return;\n}\nfunction compareVersions(a, b) {\n  return a.localeCompare(b, undefined, {\n    numeric: true\n  });\n}\nfunction isBadIOS() {\n  return isIOS() && compareVersions(osVersion() || '0.0', '15.3') < 0;\n}\n/**\n * [Big files upload error with iOS](https://github.com/kukhariev/ngx-uploadx/issues/316)\n * TODO: move to app\n */\nconst iosOverride = isBadIOS() ? {\n  chunkSize: 0,\n  retryConfig: {\n    shouldRetry: () => false\n  }\n} : {};\nlet IdService = /*#__PURE__*/(() => {\n  class IdService {\n    generateId(uploader) {\n      const print = JSON.stringify({\n        ...uploader.metadata,\n        type: uploader.constructor.name,\n        endpoint: uploader.endpoint\n      });\n      return createHash(uploader.name + uploader.size).toString(16) + createHash(print).toString(16);\n    }\n    static ɵfac = function IdService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IdService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: IdService,\n      factory: IdService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return IdService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar ErrorType = /*#__PURE__*/function (ErrorType) {\n  ErrorType[ErrorType[\"NotFound\"] = 0] = \"NotFound\";\n  ErrorType[ErrorType[\"Auth\"] = 1] = \"Auth\";\n  ErrorType[ErrorType[\"Retryable\"] = 2] = \"Retryable\";\n  ErrorType[ErrorType[\"Fatal\"] = 3] = \"Fatal\";\n  return ErrorType;\n}(ErrorType || {});\nconst defaultRetryConfig = {\n  maxAttempts: 8,\n  shouldRestartCodes: [404, 410],\n  authErrorCodes: [401],\n  shouldRetryCodes: [408, 423, 429, 460],\n  shouldRetry(code) {\n    return code < 400 || code >= 500 || this.shouldRetryCodes.includes(code);\n  },\n  minDelay: 500,\n  maxDelay: 50000,\n  onBusyDelay: 1000,\n  timeout: 0,\n  keepPartial(statusCode) {\n    return statusCode >= 400;\n  }\n};\n/**\n * Retryable ErrorHandler\n */\nclass RetryHandler {\n  attempts = 0;\n  config;\n  observedValue;\n  cancel = () => {};\n  constructor(configOptions = {}) {\n    this.config = Object.assign({}, defaultRetryConfig, configOptions);\n  }\n  /**\n   * Determine error type based on response code\n   * @param code - HTTP response status code\n   */\n  kind(code) {\n    this.attempts++;\n    if (this.attempts > this.config.maxAttempts) {\n      return ErrorType.Fatal;\n    }\n    if (this.config.authErrorCodes.includes(code)) {\n      return ErrorType.Auth;\n    }\n    if (this.config.shouldRestartCodes.includes(code)) {\n      return ErrorType.NotFound;\n    }\n    if (this.config.shouldRetry(code, this.attempts)) {\n      return ErrorType.Retryable;\n    }\n    return ErrorType.Fatal;\n  }\n  /**\n   * Wait before next retry attempt\n   * @param time - Delay in ms\n   */\n  wait(time) {\n    const ms = time || Math.min(2 ** (this.attempts - 1) * this.config.minDelay, this.config.maxDelay);\n    const jitter = Math.floor(Math.random() * this.config.minDelay * this.attempts);\n    let id;\n    return new Promise(resolve => {\n      this.cancel = () => {\n        clearTimeout(id);\n        resolve();\n      };\n      id = setTimeout(this.cancel, ms + jitter);\n    });\n  }\n  /**\n   * Observes value to reset retry attempts counter\n   * @param value - Value to observe\n   */\n  observe(value) {\n    this.observedValue !== value && (this.attempts = 0);\n    this.observedValue = value;\n  }\n}\nconst HOUR = 1000 * 60 * 60;\nclass Store {\n  prefix;\n  ttl = 24 * HOUR;\n  constructor(prefix = 'UPLOADX-v4.0-') {\n    this.prefix = prefix;\n  }\n  set(key, value) {\n    this.ttl && localStorage.setItem(this.prefix + key, JSON.stringify([value, Date.now() + this.ttl]));\n  }\n  get(key) {\n    const item = localStorage.getItem(this.prefix + key);\n    if (item) {\n      const [value, expires] = JSON.parse(item);\n      return value && expires ? value : null;\n    }\n    return null;\n  }\n  delete(key) {\n    localStorage.removeItem(this.prefix + key);\n  }\n  clear(maxAgeHours = 0) {\n    this.ttl = maxAgeHours * HOUR;\n    const now = Date.now();\n    this.keys().forEach(key => {\n      const item = localStorage.getItem(key);\n      if (item && maxAgeHours) {\n        const [, expires] = JSON.parse(item);\n        now > Number(expires) && localStorage.removeItem(key);\n      } else {\n        localStorage.removeItem(key);\n      }\n    });\n  }\n  keys() {\n    return Object.keys(localStorage).filter(key => key.indexOf(this.prefix) === 0);\n  }\n}\nconst store = isLocalStorageAvailable() ? new Store() : new Map();\nfunction isLocalStorageAvailable() {\n  try {\n    const key = 'LocalStorageTest';\n    const value = 'value';\n    localStorage.setItem(key, value);\n    const getValue = localStorage.getItem(key);\n    localStorage.removeItem(key);\n    return getValue === value;\n  } catch {\n    return false;\n  }\n}\nconst actionToStatusMap = {\n  pause: 'paused',\n  upload: 'queue',\n  cancel: 'cancelled',\n  update: 'updated'\n};\n/**\n * Uploader Base Class\n */\nclass Uploader {\n  file;\n  options;\n  stateChange;\n  ajax;\n  name;\n  size;\n  uploadId;\n  response = null;\n  responseStatus = 0;\n  responseHeaders = {};\n  progress = 0;\n  remaining;\n  speed = 0;\n  /** Custom headers */\n  headers = {};\n  /** Metadata Object */\n  metadata;\n  /** Upload endpoint */\n  endpoint = '/upload';\n  /** Chunk size in bytes */\n  chunkSize = 0;\n  /** Auth token/tokenGetter */\n  token;\n  /** Byte offset within the whole file */\n  offset;\n  /** Retries handler */\n  retry;\n  canceler = new Canceler();\n  abortController = new AbortController();\n  /** Set HttpRequest responseType */\n  responseType;\n  _authorize;\n  _prerequest;\n  _token;\n  _eventsCount = 0;\n  constructor(file, options, stateChange, ajax) {\n    this.file = file;\n    this.options = options;\n    this.stateChange = stateChange;\n    this.ajax = ajax;\n    this.retry = new RetryHandler(options.retryConfig);\n    this.name = file.name;\n    this.size = file.size;\n    this.metadata = {\n      name: file.name,\n      mimeType: file.type || 'application/octet-stream',\n      size: file.size,\n      lastModified: file.lastModified\n    };\n    options.maxChunkSize && (DynamicChunk.maxSize = options.maxChunkSize);\n    /** A function that is executed before the request is sent */\n    this._prerequest = options.prerequest || (req => req);\n    /** A function used to authorize the request */\n    this._authorize = options.authorize || (req => req);\n    this.configure(options);\n  }\n  _url = '';\n  get url() {\n    return this._url || store.get(this.uploadId) || '';\n  }\n  set url(value) {\n    this._url !== value && store.set(this.uploadId, value);\n    this._url = value;\n  }\n  _status;\n  get status() {\n    return this._status;\n  }\n  set status(s) {\n    if (s !== 'updated' && s !== 'cancelled') {\n      if (this._status === s) return;\n      if (this._status === 'complete') return;\n    }\n    if (this._status === 'cancelled') return;\n    if (this._status === 'uploading' && s === 'queue') return;\n    if (this._status === 'retry') this.retry.cancel();\n    this._status = s;\n    if (s === 'paused') this.abort();\n    if (s === 'cancelled' || s === 'complete' || s === 'error') this.cleanup();\n    if (s === 'cancelled') this.cancelAndSendState();else if (s === 'updated') this.updateAndSendState();else this.stateChange(this);\n  }\n  /**\n   * Configure uploader\n   */\n  configure({\n    metadata,\n    headers,\n    token,\n    endpoint,\n    action\n  }) {\n    endpoint && (this.endpoint = endpoint);\n    token && (this.token = token);\n    metadata && Object.assign(this.metadata, unfunc(metadata, this.file));\n    headers && Object.assign(this.headers, unfunc(headers, this.file));\n    action && (this.status = actionToStatusMap[action]);\n  }\n  /**\n   * Starts uploading\n   */\n  async upload() {\n    do {\n      this.status = 'uploading';\n      try {\n        this._token ||= await this.updateToken();\n        this.url ||= await this.getFileUrl();\n        if (this.offset !== this.size) {\n          this.offset = isNumber(this.offset) ? await this.sendFileContent() : await this.getOffset();\n        }\n        this.retry.observe(this.offset);\n        if (this.offset === this.size) {\n          this.remaining = 0;\n          this.progress = 100;\n          this.status = 'complete';\n        } else if (!isNumber(this.offset)) {\n          this.stateChange(this);\n          await this.retry.wait(this.getRetryAfterFromBackend() || this.retry.config.onBusyDelay);\n        }\n      } catch (e) {\n        e instanceof Error && console.error(e);\n        if (this.status !== 'uploading') {\n          return;\n        }\n        switch (this.retry.kind(this.responseStatus)) {\n          case ErrorType.Fatal:\n            this.status = 'error';\n            return;\n          case ErrorType.NotFound:\n            this.url = '';\n            break;\n          case ErrorType.Auth:\n            this._token = '';\n            break;\n          default:\n            if (unfunc(this.retry.config.keepPartial, this.responseStatus)) {\n              this.offset = undefined;\n            }\n            this.status = 'retry';\n            await this.retry.wait(this.getRetryAfterFromBackend());\n        }\n      }\n    } while (['uploading', 'retry', 'updated'].includes(this._status));\n  }\n  /**\n   * Performs http requests\n   */\n  async request(requestOptions) {\n    this.responseStatus = 0;\n    this.response = null;\n    this.responseHeaders = {};\n    if (this.abortController.signal.aborted) {\n      this.abortController = new AbortController();\n    }\n    const signal = requestOptions.signal || this.abortController.signal;\n    let req = {\n      body: requestOptions.body || null,\n      canceler: this.canceler,\n      signal,\n      headers: {\n        ...this.headers,\n        ...requestOptions.headers\n      },\n      method: requestOptions.method || 'GET',\n      url: requestOptions.url || this.url\n    };\n    if (!requestOptions.skipAuthorization) {\n      req = await this._authorize(req, this._token);\n    }\n    const {\n      body = null,\n      headers,\n      method,\n      url = req.url\n    } = (await this._prerequest(req)) || req;\n    const ajaxRequestConfig = {\n      method,\n      headers: {\n        ...req.headers,\n        ...headers\n      },\n      url,\n      data: body,\n      responseType: this.options.responseType ?? this.responseType,\n      withCredentials: !!this.options.withCredentials,\n      canceler: this.canceler,\n      signal,\n      validateStatus: () => true,\n      timeout: this.retry.config.timeout\n    };\n    if (isNumber(this.offset) && body && typeof body === 'object') {\n      ajaxRequestConfig.onUploadProgress = this.onProgress();\n    }\n    const response = await this.ajax.request(ajaxRequestConfig);\n    this.response = response.data;\n    this.responseHeaders = response.headers;\n    this.responseStatus = response.status;\n    if (response.status >= 400) {\n      return Promise.reject();\n    }\n  }\n  /**\n   * Set auth token string\n   */\n  updateToken = () => {\n    return unfunc(this.token || '', this.responseStatus);\n  };\n  /**\n   *  Updating the metadata of the upload\n   */\n  update(_data) {\n    return Promise.reject('Not implemented');\n  }\n  abort() {\n    this.offset = undefined;\n    this.abortController.abort();\n    this.canceler.cancel();\n  }\n  async cancel() {\n    this.abort();\n    if (this.url) {\n      await this.request({\n        method: 'DELETE'\n      }).catch(() => {});\n    }\n  }\n  /**\n   * Gets the value from the response\n   */\n  getValueFromResponse(key) {\n    return this.responseHeaders[key.toLowerCase()] || null;\n  }\n  /**\n   * Get file chunk\n   * @param offset - number of bytes of the file to skip\n   * @param size - chunk size\n   */\n  getChunk(offset, size) {\n    if (this.responseStatus === 413) {\n      DynamicChunk.maxSize = DynamicChunk.size = Math.floor(DynamicChunk.size / 2);\n    }\n    this.chunkSize = this.options.chunkSize === 0 ? this.size : this.options.chunkSize || DynamicChunk.size;\n    const start = offset ?? this.offset ?? 0;\n    const end = Math.min(start + (size || this.chunkSize), this.size);\n    const body = this.file.slice(start, end);\n    return {\n      start,\n      end,\n      body\n    };\n  }\n  getRetryAfterFromBackend() {\n    return Number(this.getValueFromResponse('retry-after')) * 1000;\n  }\n  cancelAndSendState() {\n    this.cancel().then(() => this.stateChange(this), console.error);\n  }\n  updateAndSendState() {\n    this.update({\n      metadata: this.metadata\n    }).then(() => this.stateChange(this), console.error);\n  }\n  cleanup = () => {\n    store.delete(this._url);\n    store.delete(this.uploadId);\n  };\n  onProgress() {\n    let throttle;\n    const startTime = Date.now();\n    return ({\n      loaded\n    }) => {\n      const current = loaded / ((Date.now() - startTime) / 1000);\n      this.speed = ~~((this.speed * this._eventsCount + current) / ++this._eventsCount);\n      DynamicChunk.scale(this.speed);\n      if (!throttle) {\n        throttle = setTimeout(() => throttle = undefined, 500);\n        const uploaded = (this.offset || 0) + loaded;\n        this.progress = +(uploaded / this.size * 100).toFixed(2);\n        this.remaining = ~~((this.size - uploaded) / this.speed);\n        this.stateChange(this);\n      }\n    };\n  }\n}\n\n/**\n * Implements XHR/CORS Resumable Upload\n * {@link https://github.com/kukhariev/node-uploadx/blob/master/proto.md Github}\n * @see {@link https://developers.google.com/drive/api/v3/manage-uploads#resumable Google Drive API documentation}\n */\nclass UploaderX extends Uploader {\n  responseType = 'json';\n  async getFileUrl() {\n    const body = JSON.stringify(this.metadata);\n    const headers = {\n      'Content-Type': 'application/json; charset=utf-8',\n      'X-Upload-Content-Length': this.size,\n      'X-Upload-Content-Type': this.file.type || 'application/octet-stream'\n    };\n    await this.request({\n      method: 'POST',\n      body,\n      url: this.endpoint,\n      headers\n    });\n    this.offset = this.getOffsetFromResponse() || (this.responseStatus === 201 ? 0 : undefined);\n    const location = this.getValueFromResponse('location');\n    if (!location) {\n      throw new Error('Invalid or missing Location header');\n    }\n    return resolveUrl(location, this.endpoint);\n  }\n  async sendFileContent() {\n    const {\n      body,\n      start,\n      end\n    } = this.getChunk();\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'Content-Range': `bytes ${start}-${end - 1}/${this.size}`\n    };\n    await this.request({\n      method: 'PUT',\n      body,\n      headers\n    });\n    return this.responseStatus > 201 ? this.getOffsetFromResponse() : end;\n  }\n  async getOffset() {\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'Content-Range': `bytes */${this.size}`\n    };\n    await this.request({\n      method: 'PUT',\n      headers\n    });\n    return this.responseStatus > 201 ? this.getOffsetFromResponse() : this.size;\n  }\n  async update(data) {\n    const body = JSON.stringify(data);\n    const headers = {\n      'Content-Type': 'application/json; charset=utf-8'\n    };\n    await this.request({\n      method: 'PATCH',\n      body,\n      headers\n    });\n    const location = this.getValueFromResponse('location') || this.url;\n    return resolveUrl(location, this.endpoint);\n  }\n  getOffsetFromResponse() {\n    const range = this.getValueFromResponse('Range');\n    return range ? getRangeEnd(range) + 1 : undefined;\n  }\n}\nfunction getRangeEnd(range = '') {\n  const end = parseInt(range.split(/-/)[1], 10);\n  return end >= 0 ? end : -1;\n}\nconst defaultOptions = {\n  endpoint: '/upload',\n  autoUpload: true,\n  concurrency: 2,\n  uploaderClass: UploaderX,\n  authorize: (req, token) => {\n    token && (req.headers['Authorization'] = `Bearer ${token}`);\n    return req;\n  },\n  storeIncompleteHours: 24\n};\nconst UPLOADX_FACTORY_OPTIONS = new InjectionToken('uploadx.factory.options', {\n  providedIn: 'root',\n  factory: () => defaultOptions\n});\nconst UPLOADX_OPTIONS = new InjectionToken('uploadx.options');\n\n/**\n * Implements tus resumable upload protocol\n * {@link https://github.com/tus/tus-resumable-upload-protocol/blob/master/protocol.md  Github}\n */\nclass Tus extends Uploader {\n  headers = {\n    'Tus-Resumable': '1.0.0'\n  };\n  async getFileUrl() {\n    const encodedMetaData = b64.serialize(this.metadata);\n    const headers = {\n      'Upload-Length': this.size,\n      'Upload-Metadata': encodedMetaData\n    };\n    await this.request({\n      method: 'POST',\n      url: this.endpoint,\n      headers\n    });\n    this.offset = this.getOffsetFromResponse() || (this.responseStatus === 201 ? 0 : undefined);\n    const location = this.getValueFromResponse('location');\n    if (!location) {\n      throw new Error('Invalid or missing Location header');\n    }\n    return resolveUrl(location, this.endpoint);\n  }\n  async sendFileContent() {\n    const {\n      body,\n      start,\n      end\n    } = this.getChunk();\n    const headers = {\n      'Content-Type': 'application/offset+octet-stream',\n      'Upload-Offset': start\n    };\n    await this.request({\n      method: 'PATCH',\n      body,\n      headers\n    });\n    return this.getOffsetFromResponse() || end;\n  }\n  async getOffset() {\n    await this.request({\n      method: 'HEAD'\n    });\n    return this.getOffsetFromResponse();\n  }\n  getOffsetFromResponse() {\n    const offset = this.getValueFromResponse('Upload-Offset');\n    return offset ? parseInt(offset, 10) : undefined;\n  }\n}\nconst UPLOAD_STATE_KEYS = ['file', 'name', 'progress', 'remaining', 'response', 'responseHeaders', 'responseStatus', 'size', 'speed', 'status', 'uploadId', 'url'];\nconst DUE_TIME = 5;\nlet UploadxService = /*#__PURE__*/(() => {\n  class UploadxService {\n    /** Upload Queue */\n    queue = [];\n    options;\n    eventsStream = new Subject();\n    subs = [];\n    ngZone = inject(NgZone);\n    ajax = inject(UPLOADX_AJAX);\n    idService = inject(IdService);\n    constructor() {\n      const options = inject(UPLOADX_OPTIONS, {\n        optional: true\n      });\n      const defaults = inject(UPLOADX_FACTORY_OPTIONS);\n      this.options = Object.assign({}, defaults, options);\n      if (isBrowser()) {\n        this.subs.push(fromEvent(window, 'online').subscribe(() => this.control({\n          action: 'upload'\n        })), fromEvent(window, 'offline').subscribe(() => this.control({\n          action: 'pause'\n        })));\n      }\n    }\n    /** Upload status events */\n    get events() {\n      return this.eventsStream.asObservable();\n    }\n    /**\n     * Initializes service\n     * @param options global module options\n     * @returns Observable that emits a new value on progress or status changes\n     */\n    init(options = {}) {\n      Object.assign(this.options, options);\n      return this.events;\n    }\n    /**\n     * Initializes service\n     * @param options global module options\n     * @returns Observable that emits the current array of uploaders\n     */\n    connect(options) {\n      return this.init(options).pipe(map(() => this.queue), debounceTime(DUE_TIME));\n    }\n    /**\n     * Terminates all uploads and clears the queue\n     */\n    disconnect() {\n      this.queue.forEach(uploader => uploader.status = 'paused');\n      this.queue = [];\n    }\n    /**\n     * Returns current uploads state\n     * @example\n     * // restore background uploads\n     * this.uploads = this.uploadService.state();\n     */\n    state() {\n      return this.queue.map(uploader => pick(uploader, UPLOAD_STATE_KEYS));\n    }\n    ngOnDestroy() {\n      this.disconnect();\n      this.subs.forEach(sub => sub.unsubscribe());\n    }\n    /**\n     * Creates uploaders for files and adds them to the upload queue\n     */\n    handleFiles(files, options = {}) {\n      const instanceOptions = {\n        ...this.options,\n        ...iosOverride,\n        ...options\n      };\n      store.clear(instanceOptions.storeIncompleteHours);\n      this.options.concurrency = instanceOptions.concurrency;\n      ('name' in files ? [files] : Array.from(files)).forEach(file => this.addUploaderInstance(file, instanceOptions));\n    }\n    /**\n     * Upload control\n     * @example\n     * // pause all\n     * this.uploadService.control({ action: 'pause' });\n     * // pause upload with uploadId\n     * this.uploadService.control({ action: 'pause', uploadId});\n     * // set token\n     * this.uploadService.control({ token: `TOKEN` });\n     */\n    control(evt) {\n      const target = evt.uploadId ? this.queue.filter(({\n        uploadId\n      }) => uploadId === evt.uploadId) : this.queue;\n      target.forEach(uploader => uploader.configure(evt));\n    }\n    /**\n     * Number of active uploads\n     */\n    get activeUploadsCount() {\n      return this.queue.filter(({\n        status\n      }) => status === 'uploading' || status === 'retry').length;\n    }\n    /**\n     * Performs http requests\n     */\n    async request(config) {\n      config.data ||= config.body;\n      return this.ajax.request(config);\n    }\n    stateChange = uploader => {\n      this.ngZone.run(() => this.eventsStream.next(pick(uploader, UPLOAD_STATE_KEYS)));\n      if (uploader.status !== 'uploading' && uploader.status !== 'added') {\n        this.ngZone.runOutsideAngular(() => setTimeout(() => this.processQueue()));\n      }\n    };\n    async addUploaderInstance(file, options) {\n      const uploader = new options.uploaderClass(file, options, this.stateChange, this.ajax);\n      uploader.uploadId = await this.idService.generateId(uploader);\n      this.queue.push(uploader);\n      uploader.status = 'added';\n      if (options.autoUpload && onLine()) {\n        uploader.status = 'queue';\n      }\n    }\n    processQueue() {\n      this.queue = this.queue.filter(({\n        status\n      }) => status !== 'cancelled');\n      this.queue.filter(({\n        status\n      }) => status === 'queue').slice(0, Math.max(this.options.concurrency - this.activeUploadsCount, 0)).forEach(uploader => uploader.upload());\n    }\n    static ɵfac = function UploadxService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UploadxService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: UploadxService,\n      factory: UploadxService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return UploadxService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UploadxDirective = /*#__PURE__*/(() => {\n  class UploadxDirective {\n    elementRef;\n    renderer;\n    uploadService;\n    set uploadx(value) {\n      if (value) {\n        this.options = value;\n      }\n    }\n    options = {};\n    set control(value) {\n      if (value) {\n        this.uploadService.control(value);\n      }\n    }\n    state = new EventEmitter();\n    constructor(elementRef, renderer, uploadService) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.uploadService = uploadService;\n    }\n    ngOnInit() {\n      const {\n        multiple,\n        allowedTypes\n      } = {\n        ...this.uploadService.options,\n        ...this.options\n      };\n      multiple !== false && this.renderer.setAttribute(this.elementRef.nativeElement, 'multiple', '');\n      allowedTypes && this.renderer.setAttribute(this.elementRef.nativeElement, 'accept', allowedTypes);\n      this.uploadService.events.pipe(takeWhile(() => this.state.observers.length > 0)).subscribe(this.state);\n    }\n    fileListener(files) {\n      if (files?.length) {\n        this.uploadService.handleFiles(files, this.options);\n      }\n    }\n    static ɵfac = function UploadxDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UploadxDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(UploadxService));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: UploadxDirective,\n      selectors: [[\"\", \"uploadx\", \"\"]],\n      hostBindings: function UploadxDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"change\", function UploadxDirective_change_HostBindingHandler($event) {\n            return ctx.fileListener($event.target.files);\n          });\n        }\n      },\n      inputs: {\n        uploadx: \"uploadx\",\n        options: \"options\",\n        control: \"control\"\n      },\n      outputs: {\n        state: \"state\"\n      }\n    });\n  }\n  return UploadxDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UploadxDropDirective = /*#__PURE__*/(() => {\n  class UploadxDropDirective {\n    uploadService;\n    active = false;\n    fileInput;\n    constructor(uploadService) {\n      this.uploadService = uploadService;\n    }\n    dropHandler(event) {\n      this._stopEvents(event);\n      this.active = false;\n      const files = this.getFiles(event);\n      if (files.length) {\n        this.fileInput ? this.fileInput.fileListener(files) : this.uploadService.handleFiles(files);\n      }\n    }\n    onDragOver(event) {\n      this._stopEvents(event);\n      if (event.dataTransfer?.items[0]?.kind === 'file') {\n        if (this.fileInput?.options.multiple === false && event.dataTransfer.items.length > 1) {\n          event.dataTransfer.dropEffect = 'none';\n        } else {\n          event.dataTransfer.dropEffect = 'copy';\n          this.active = true;\n        }\n      }\n    }\n    onDragLeave(event) {\n      this._stopEvents(event);\n      this.active = false;\n    }\n    /**\n     * Extracts the files from a `DragEvent` object\n     */\n    getFiles(event) {\n      const dataTransfer = new DataTransfer();\n      const items = event.dataTransfer?.items;\n      if (items?.length) {\n        for (let i = 0; i < items.length; i++) {\n          const item = items[i];\n          if (item.kind === 'file' && !item.webkitGetAsEntry()?.isDirectory) {\n            const file = item.getAsFile();\n            file && dataTransfer.items.add(file);\n          }\n        }\n      }\n      return dataTransfer.files;\n    }\n    _stopEvents(event) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n    static ɵfac = function UploadxDropDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UploadxDropDirective)(i0.ɵɵdirectiveInject(UploadxService));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: UploadxDropDirective,\n      selectors: [[\"\", \"uploadxDrop\", \"\"]],\n      contentQueries: function UploadxDropDirective_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, UploadxDirective, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fileInput = _t.first);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function UploadxDropDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"drop\", function UploadxDropDirective_drop_HostBindingHandler($event) {\n            return ctx.dropHandler($event);\n          })(\"dragover\", function UploadxDropDirective_dragover_HostBindingHandler($event) {\n            return ctx.onDragOver($event);\n          })(\"dragleave\", function UploadxDropDirective_dragleave_HostBindingHandler($event) {\n            return ctx.onDragLeave($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"uploadx-drop-active\", ctx.active);\n        }\n      }\n    });\n  }\n  return UploadxDropDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UploadxModule = /*#__PURE__*/(() => {\n  class UploadxModule {\n    static withConfig(options) {\n      return {\n        ngModule: UploadxModule,\n        providers: [{\n          provide: UPLOADX_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n    static ɵfac = function UploadxModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UploadxModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: UploadxModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return UploadxModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Provides configuration options for standalone app.\n *\n * @example\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideUploadx({\n *       endpoint: uploadUrl,\n *       allowedTypes: 'video/*,audio/*',\n *       maxChunkSize: 96 * 1024 * 1024\n *     })\n *   ]\n * });\n * ```\n */\nfunction provideUploadx(options = {}) {\n  const providers = [{\n    provide: UPLOADX_OPTIONS,\n    useValue: options\n  }];\n  return providers;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Canceler, DynamicChunk, ErrorType, IdService, RetryHandler, Store, Tus, UPLOADX_AJAX, UPLOADX_FACTORY_OPTIONS, UPLOADX_OPTIONS, UPLOAD_STATE_KEYS, Uploader, UploaderX, UploadxAjax, UploadxDirective, UploadxDropDirective, UploadxModule, UploadxService, b64, compareVersions, createHash, getRangeEnd, iosOverride, isBadIOS, isBrowser, isIOS, isLocalStorageAvailable, isNumber, onLine, osVersion, pick, provideUploadx, resolveUrl, store, unfunc };\n","@if (error()) {\n  @if (enableRetryAfterError()) {\n    <div class=\"d-flex\">\n      <my-progress-bar\n        [label]=\"error()\" value=\"100\" [valueFormatted]=\"error()\"\n        theme=\"red\"\n      >\n      </my-progress-bar>\n\n      <input type=\"button\" class=\"peertube-button secondary-button ms-1\" i18n-value=\"Retry failed upload\" value=\"Retry\" (click)=\"retry.emit()\" />\n    </div>\n  } @else {\n    <my-alert type=\"danger\">\n      <div i18n>Sorry, but something went wrong.</div>\n\n      {{ error() }}\n    </my-alert>\n  }\n} @else if (isUploading() || uploaded()){\n  <div>\n    <my-progress-bar\n      i18n-label label=\"Total uploaded\" theme=\"green\"\n      [value]=\"uploadPercents()\" [valueFormatted]=\"getUploadingLabel()\"\n    >\n    </my-progress-bar>\n  </div>\n}\n","import { CommonModule } from '@angular/common'\nimport { Component, input, output } from '@angular/core'\nimport { AlertComponent } from '../shared-main/common/alert.component'\nimport { ProgressBarComponent } from '../shared-main/common/progress-bar.component'\n\n@Component({\n  selector: 'my-upload-progress',\n  templateUrl: './upload-progress.component.html',\n  styleUrls: [ './upload-progress.component.scss' ],\n  imports: [ CommonModule, ProgressBarComponent, AlertComponent ]\n})\nexport class UploadProgressComponent {\n  readonly isUploading = input<boolean>(undefined)\n  readonly uploadPercents = input<number>(undefined)\n  readonly error = input<string>(undefined)\n  readonly uploaded = input<boolean>(undefined)\n  readonly enableRetryAfterError = input<boolean>(undefined)\n  readonly uploadedLabel = input<string>()\n\n  readonly retry = output()\n\n  getUploadingLabel () {\n    if (this.uploaded()) return this.uploadedLabel() || $localize`File uploaded!`\n\n    const uploadPercents = this.uploadPercents()\n    if (uploadPercents === 100) return $localize`Processing…`\n\n    return $localize`${uploadPercents}%`\n  }\n}\n"]}
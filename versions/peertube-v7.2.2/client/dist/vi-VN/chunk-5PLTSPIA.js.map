{
  "version": 3,
  "sources": ["src/app/shared/shared-video-playlist/video-playlist.service.ts", "src/app/shared/shared-video-playlist/video-playlist-element.model.ts", "src/app/shared/shared-video-playlist/video-playlist.model.ts"],
  "sourcesContent": ["import debug from 'debug'\nimport { merge, Observable, of, ReplaySubject, Subject } from 'rxjs'\nimport { catchError, filter, map, share, switchMap, tap } from 'rxjs/operators'\nimport { HttpClient, HttpContext, HttpParams } from '@angular/common/http'\nimport { Injectable, inject } from '@angular/core'\nimport { AuthService, AuthUser, ComponentPaginationLight, RestExtractor, RestService, ServerService } from '@app/core'\nimport { buildBulkObservable, objectToFormData } from '@app/helpers'\nimport { NGX_LOADING_BAR_IGNORED } from '@ngx-loading-bar/http-client'\nimport {\n  CachedVideoExistInPlaylist,\n  CachedVideosExistInPlaylists,\n  ResultList,\n  VideoExistInPlaylist,\n  VideoPlaylist as VideoPlaylistServerModel,\n  VideoPlaylistCreate,\n  VideoPlaylistElement as ServerVideoPlaylistElement,\n  VideoPlaylistElementCreate,\n  VideoPlaylistElementUpdate,\n  VideoPlaylistReorder,\n  VideoPlaylistUpdate,\n  VideosExistInPlaylists\n} from '@peertube/peertube-models'\nimport { environment } from '../../../environments/environment'\nimport { VideoPlaylistElement } from './video-playlist-element.model'\nimport { VideoPlaylist } from './video-playlist.model'\nimport { VideoChannel } from '../shared-main/channel/video-channel.model'\nimport { VideoChannelService } from '../shared-main/channel/video-channel.service'\nimport { AccountService } from '../shared-main/account/account.service'\nimport { Account } from '../shared-main/account/account.model'\n\nconst debugLogger = debug('peertube:playlists:VideoPlaylistService')\n\nexport type CachedPlaylist = VideoPlaylist | { id: number, displayName: string }\n\n@Injectable()\nexport class VideoPlaylistService {\n  private authHttp = inject(HttpClient)\n  private auth = inject(AuthService)\n  private serverService = inject(ServerService)\n  private restExtractor = inject(RestExtractor)\n  private restService = inject(RestService)\n\n  static BASE_VIDEO_PLAYLIST_URL = environment.apiUrl + '/api/v1/video-playlists/'\n  static MY_VIDEO_PLAYLIST_URL = environment.apiUrl + '/api/v1/users/me/video-playlists/'\n\n  // Use a replay subject because we \"next\" a value before subscribing\n  private videoExistsInPlaylistNotifier = new ReplaySubject<number>(1)\n  private videoExistsInPlaylistCacheSubject = new Subject<CachedVideosExistInPlaylists>()\n  private readonly videoExistsInPlaylistObservable: Observable<CachedVideosExistInPlaylists>\n\n  private videoExistsObservableCache: { [id: number]: Observable<CachedVideoExistInPlaylist[]> } = {}\n  private videoExistsCache: { [id: number]: CachedVideoExistInPlaylist[] } = {}\n\n  private myAccountPlaylistCache: ResultList<CachedPlaylist> = undefined\n  private myAccountPlaylistCacheRunning: Observable<ResultList<CachedPlaylist>>\n  private myAccountPlaylistCacheSubject = new Subject<ResultList<CachedPlaylist>>()\n\n  constructor () {\n    this.videoExistsInPlaylistObservable = merge(\n      buildBulkObservable({\n        time: 200,\n        bulkGet: (videoIds: number[]) => {\n          // We added a delay to the request, so ensure the user is still logged in\n          if (this.auth.isLoggedIn()) {\n            return this.doVideosExistInPlaylist(videoIds)\n          }\n\n          return of({})\n        },\n        notifierObservable: this.videoExistsInPlaylistNotifier\n      }).pipe(map(({ response }) => response)),\n      this.videoExistsInPlaylistCacheSubject\n    )\n  }\n\n  listChannelPlaylists (videoChannel: VideoChannel, componentPagination: ComponentPaginationLight): Observable<ResultList<VideoPlaylist>> {\n    const url = VideoChannelService.BASE_VIDEO_CHANNEL_URL + videoChannel.nameWithHost + '/video-playlists'\n    const pagination = this.restService.componentToRestPagination(componentPagination)\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, pagination)\n\n    return this.authHttp.get<ResultList<VideoPlaylist>>(url, { params })\n      .pipe(\n        switchMap(res => this.extractPlaylists(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  listMyPlaylistWithCache (user: AuthUser, search?: string) {\n    if (!search) {\n      if (this.myAccountPlaylistCacheRunning) return this.myAccountPlaylistCacheRunning\n      if (this.myAccountPlaylistCache) return of(this.myAccountPlaylistCache)\n    }\n\n    const obs = this.listAccountPlaylists(user.account, undefined, '-updatedAt', search)\n      .pipe(\n        tap(result => {\n          if (!search) {\n            this.myAccountPlaylistCacheRunning = undefined\n            this.myAccountPlaylistCache = result\n          }\n        }),\n        share()\n      )\n\n    if (!search) this.myAccountPlaylistCacheRunning = obs\n    return obs\n  }\n\n  listAccountPlaylists (\n    account: Account,\n    componentPagination: ComponentPaginationLight,\n    sort: string,\n    search?: string\n  ): Observable<ResultList<VideoPlaylist>> {\n    const url = AccountService.BASE_ACCOUNT_URL + account.nameWithHost + '/video-playlists'\n    const pagination = componentPagination\n      ? this.restService.componentToRestPagination(componentPagination)\n      : undefined\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, pagination, sort)\n    if (search) params = this.restService.addObjectParams(params, { search })\n\n    return this.authHttp.get<ResultList<VideoPlaylist>>(url, { params })\n      .pipe(\n        switchMap(res => this.extractPlaylists(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  getVideoPlaylist (id: string | number) {\n    const url = VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + id\n\n    return this.authHttp.get<VideoPlaylist>(url)\n      .pipe(\n        switchMap(res => this.extractPlaylist(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  createVideoPlaylist (body: VideoPlaylistCreate) {\n    const data = objectToFormData(body)\n\n    return this.authHttp.post<{ videoPlaylist: { id: number } }>(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL, data)\n      .pipe(\n        tap(res => {\n          if (!this.myAccountPlaylistCache) return\n\n          this.myAccountPlaylistCache.total++\n\n          this.myAccountPlaylistCache.data.push({\n            id: res.videoPlaylist.id,\n            displayName: body.displayName\n          })\n\n          this.myAccountPlaylistCacheSubject.next(this.myAccountPlaylistCache)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  updateVideoPlaylist (videoPlaylist: VideoPlaylist, body: VideoPlaylistUpdate) {\n    const data = objectToFormData(body)\n\n    return this.authHttp.put(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + videoPlaylist.id, data)\n      .pipe(\n        tap(() => {\n          if (!this.myAccountPlaylistCache) return\n\n          const playlist = this.myAccountPlaylistCache.data.find(p => p.id === videoPlaylist.id)\n          playlist.displayName = body.displayName\n\n          this.myAccountPlaylistCacheSubject.next(this.myAccountPlaylistCache)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  removeVideoPlaylist (videoPlaylist: VideoPlaylist) {\n    return this.authHttp.delete(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + videoPlaylist.id)\n      .pipe(\n        tap(() => {\n          if (!this.myAccountPlaylistCache) return\n\n          this.myAccountPlaylistCache.total--\n          this.myAccountPlaylistCache.data = this.myAccountPlaylistCache.data\n            .filter(p => p.id !== videoPlaylist.id)\n\n          this.myAccountPlaylistCacheSubject.next(this.myAccountPlaylistCache)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  addVideoInPlaylist (playlistId: number, body: VideoPlaylistElementCreate) {\n    const url = VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + playlistId + '/videos'\n\n    return this.authHttp.post<{ videoPlaylistElement: { id: number } }>(url, body)\n      .pipe(\n        tap(res => {\n          const existsResult = this.videoExistsCache[body.videoId]\n          existsResult.push({\n            playlistId,\n            playlistElementId: res.videoPlaylistElement.id,\n            startTimestamp: body.startTimestamp,\n            stopTimestamp: body.stopTimestamp\n          })\n\n          this.runVideoExistsInPlaylistCheck(body.videoId)\n\n          if (this.myAccountPlaylistCache) {\n            const playlist = this.myAccountPlaylistCache.data.find(p => p.id === playlistId)\n            if (!playlist) return\n\n            const otherPlaylists = this.myAccountPlaylistCache.data.filter(p => p !== playlist)\n            this.myAccountPlaylistCache.data = [ playlist, ...otherPlaylists ]\n          }\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  updateVideoOfPlaylist (playlistId: number, playlistElementId: number, body: VideoPlaylistElementUpdate, videoId: number) {\n    return this.authHttp.put(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + playlistId + '/videos/' + playlistElementId, body)\n      .pipe(\n        tap(() => {\n          const existsResult = this.videoExistsCache[videoId]\n\n          if (existsResult) {\n            const elem = existsResult.find(e => e.playlistElementId === playlistElementId)\n\n            elem.startTimestamp = body.startTimestamp\n            elem.stopTimestamp = body.stopTimestamp\n          }\n\n          this.runVideoExistsInPlaylistCheck(videoId)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  removeVideoFromPlaylist (playlistId: number, playlistElementId: number, videoId?: number) {\n    return this.authHttp.delete(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + playlistId + '/videos/' + playlistElementId)\n      .pipe(\n        tap(() => {\n          if (!videoId) return\n\n          if (this.videoExistsCache[videoId]) {\n            this.videoExistsCache[videoId] = this.videoExistsCache[videoId]\n              .filter(e => e.playlistElementId !== playlistElementId)\n          }\n\n          this.runVideoExistsInPlaylistCheck(videoId)\n        }),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  reorderPlaylist (playlistId: number, oldPosition: number, newPosition: number) {\n    const body: VideoPlaylistReorder = {\n      startPosition: oldPosition,\n      insertAfterPosition: newPosition\n    }\n\n    return this.authHttp.post(VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + playlistId + '/videos/reorder', body)\n      .pipe(catchError(err => this.restExtractor.handleError(err)))\n  }\n\n  getPlaylistVideos (options: {\n    videoPlaylistId: number | string\n    componentPagination: ComponentPaginationLight\n  }): Observable<ResultList<VideoPlaylistElement>> {\n    const path = VideoPlaylistService.BASE_VIDEO_PLAYLIST_URL + options.videoPlaylistId + '/videos'\n    const pagination = this.restService.componentToRestPagination(options.componentPagination)\n\n    let params = new HttpParams()\n    params = this.restService.addRestGetParams(params, pagination)\n\n    return this.authHttp\n      .get<ResultList<ServerVideoPlaylistElement>>(path, { params })\n      .pipe(\n        switchMap(res => this.extractVideoPlaylistElements(res)),\n        catchError(err => this.restExtractor.handleError(err))\n      )\n  }\n\n  listenToMyAccountPlaylistsChange () {\n    return this.myAccountPlaylistCacheSubject.asObservable()\n  }\n\n  listenToVideoPlaylistChange (videoId: number) {\n    if (this.videoExistsObservableCache[videoId]) {\n      return this.videoExistsObservableCache[videoId]\n    }\n\n    const obs = this.videoExistsInPlaylistObservable\n      .pipe(\n        map(existsResult => existsResult[videoId]),\n        filter(r => !!r),\n        tap(result => this.videoExistsCache[videoId] = result)\n      )\n\n    this.videoExistsObservableCache[videoId] = obs\n    return obs\n  }\n\n  runVideoExistsInPlaylistCheck (videoId: number) {\n    debugLogger('Running playlist check.')\n\n    if (this.videoExistsCache[videoId]) {\n      debugLogger('Found cache for %d.', videoId)\n\n      return this.videoExistsInPlaylistCacheSubject.next({ [videoId]: this.videoExistsCache[videoId] })\n    }\n\n    debugLogger('Fetching from network for %d.', videoId)\n    return this.videoExistsInPlaylistNotifier.next(videoId)\n  }\n\n  extractPlaylists (result: ResultList<VideoPlaylistServerModel>) {\n    return this.serverService.getServerLocale()\n      .pipe(\n        map(translations => {\n          const playlistsJSON = result.data\n          const total = result.total\n          const playlists: VideoPlaylist[] = []\n\n          for (const playlistJSON of playlistsJSON) {\n            playlists.push(new VideoPlaylist(playlistJSON, translations))\n          }\n\n          return { data: playlists, total }\n        })\n      )\n  }\n\n  extractPlaylist (playlist: VideoPlaylistServerModel) {\n    return this.serverService.getServerLocale()\n      .pipe(map(translations => new VideoPlaylist(playlist, translations)))\n  }\n\n  extractVideoPlaylistElements (result: ResultList<ServerVideoPlaylistElement>) {\n    return this.serverService.getServerLocale()\n      .pipe(\n        map(translations => {\n          const elementsJson = result.data\n          const total = result.total\n          const elements: VideoPlaylistElement[] = []\n\n          for (const elementJson of elementsJson) {\n            elements.push(new VideoPlaylistElement(elementJson, translations))\n          }\n\n          return { total, data: elements }\n        })\n      )\n  }\n\n  doVideosExistInPlaylist (videoIds: number[]): Observable<VideosExistInPlaylists> {\n    const url = VideoPlaylistService.MY_VIDEO_PLAYLIST_URL + 'videos-exist'\n\n    let params = new HttpParams()\n    params = this.restService.addObjectParams(params, { videoIds })\n\n    return this.authHttp.get<VideoExistInPlaylist>(url, { params, context: new HttpContext().set(NGX_LOADING_BAR_IGNORED, true) })\n      .pipe(catchError(err => this.restExtractor.handleError(err)))\n  }\n}\n", "import { Video } from '@app/shared/shared-main/video/video.model'\nimport { VideoPlaylistElement as ServerVideoPlaylistElement, VideoPlaylistElementType_Type } from '@peertube/peertube-models'\n\nexport class VideoPlaylistElement implements ServerVideoPlaylistElement {\n  id: number\n  position: number\n  startTimestamp: number\n  stopTimestamp: number\n\n  type: VideoPlaylistElementType_Type\n\n  video?: Video\n\n  constructor (hash: ServerVideoPlaylistElement, translations: { [ id: string ]: string } = {}) {\n    this.id = hash.id\n    this.position = hash.position\n    this.startTimestamp = hash.startTimestamp\n    this.stopTimestamp = hash.stopTimestamp\n\n    this.type = hash.type\n\n    if (hash.video) this.video = new Video(hash.video, translations)\n  }\n}\n", "import { getAPIUrl, getOriginUrl } from '@app/helpers'\nimport { buildPlaylistWatchPath, peertubeTranslate } from '@peertube/peertube-core-utils'\nimport {\n  AccountSummary,\n  VideoPlaylist as ServerVideoPlaylist,\n  VideoChannelSummary,\n  VideoConstant,\n  VideoPlaylistPrivacyType,\n  VideoPlaylistType,\n  VideoPlaylistType_Type\n} from '@peertube/peertube-models'\nimport { Actor } from '../shared-main/account/actor.model'\n\nexport class VideoPlaylist implements ServerVideoPlaylist {\n  id: number\n  uuid: string\n  shortUUID: string\n\n  isLocal: boolean\n\n  url: string\n\n  displayName: string\n  description: string\n  privacy: VideoConstant<VideoPlaylistPrivacyType>\n\n  videosLength: number\n\n  type: VideoConstant<VideoPlaylistType_Type>\n\n  createdAt: Date | string\n  updatedAt: Date | string\n\n  ownerAccount: AccountSummary\n  videoChannel?: VideoChannelSummary\n\n  thumbnailPath: string\n  thumbnailUrl: string\n\n  embedPath: string\n  embedUrl: string\n\n  ownerBy: string\n\n  videoChannelBy?: string\n\n  static buildWatchUrl (playlist: Pick<VideoPlaylist, 'uuid' | 'shortUUID'>) {\n    return buildPlaylistWatchPath({ shortUUID: playlist.shortUUID || playlist.uuid })\n  }\n\n  constructor (hash: ServerVideoPlaylist, translations: { [id: string]: string }) {\n    this.id = hash.id\n    this.uuid = hash.uuid\n    this.shortUUID = hash.shortUUID\n\n    this.url = hash.url\n    this.isLocal = hash.isLocal\n\n    this.displayName = hash.displayName\n\n    this.description = hash.description\n    this.privacy = hash.privacy\n\n    this.thumbnailPath = hash.thumbnailPath\n\n    this.thumbnailUrl = this.thumbnailPath\n      ? hash.thumbnailUrl || (getAPIUrl() + hash.thumbnailPath)\n      : getAPIUrl() + '/client/assets/images/default-playlist.jpg'\n\n    this.embedPath = hash.embedPath\n    this.embedUrl = hash.embedUrl || (getOriginUrl() + hash.embedPath)\n\n    this.videosLength = hash.videosLength\n\n    this.type = hash.type\n\n    this.createdAt = new Date(hash.createdAt)\n    this.updatedAt = new Date(hash.updatedAt)\n\n    this.ownerAccount = hash.ownerAccount\n    this.ownerBy = Actor.CREATE_BY_STRING(hash.ownerAccount.name, hash.ownerAccount.host)\n\n    if (hash.videoChannel) {\n      this.videoChannel = hash.videoChannel\n      this.videoChannelBy = Actor.CREATE_BY_STRING(hash.videoChannel.name, hash.videoChannel.host)\n    }\n\n    this.privacy.label = peertubeTranslate(this.privacy.label, translations)\n\n    if (this.type.id === VideoPlaylistType.WATCH_LATER) {\n      this.displayName = peertubeTranslate(this.displayName, translations)\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_debug", "VideoPlaylistElement", "id", "position", "startTimestamp", "stopTimestamp", "type", "video", "constructor", "hash", "translations", "Video", "VideoPlaylist", "id", "uuid", "shortUUID", "isLocal", "url", "displayName", "description", "privacy", "videosLength", "type", "createdAt", "updatedAt", "ownerAccount", "videoChannel", "thumbnailPath", "thumbnailUrl", "embedPath", "embedUrl", "ownerBy", "videoChannelBy", "buildWatchUrl", "playlist", "buildPlaylistWatchPath", "constructor", "hash", "translations", "getAPIUrl", "getOriginUrl", "Date", "Actor", "CREATE_BY_STRING", "name", "host", "label", "peertubeTranslate", "VideoPlaylistType", "WATCH_LATER", "debugLogger", "debug", "VideoPlaylistService", "authHttp", "inject", "HttpClient", "auth", "AuthService", "serverService", "ServerService", "restExtractor", "RestExtractor", "restService", "RestService", "videoExistsInPlaylistNotifier", "ReplaySubject", "videoExistsInPlaylistCacheSubject", "Subject", "videoExistsInPlaylistObservable", "videoExistsObservableCache", "videoExistsCache", "myAccountPlaylistCache", "undefined", "myAccountPlaylistCacheRunning", "myAccountPlaylistCacheSubject", "constructor", "merge", "buildBulkObservable", "time", "bulkGet", "videoIds", "isLoggedIn", "doVideosExistInPlaylist", "of", "notifierObservable", "pipe", "map", "response", "listChannelPlaylists", "videoChannel", "componentPagination", "url", "VideoChannelService", "BASE_VIDEO_CHANNEL_URL", "nameWithHost", "pagination", "componentToRestPagination", "params", "HttpParams", "addRestGetParams", "get", "switchMap", "res", "extractPlaylists", "catchError", "err", "handleError", "listMyPlaylistWithCache", "user", "search", "obs", "listAccountPlaylists", "account", "tap", "result", "share", "sort", "AccountService", "BASE_ACCOUNT_URL", "addObjectParams", "getVideoPlaylist", "id", "BASE_VIDEO_PLAYLIST_URL", "extractPlaylist", "createVideoPlaylist", "body", "data", "objectToFormData", "post", "total", "push", "videoPlaylist", "displayName", "next", "updateVideoPlaylist", "put", "playlist", "find", "p", "removeVideoPlaylist", "delete", "filter", "addVideoInPlaylist", "playlistId", "videoId", "playlistElementId", "videoPlaylistElement", "startTimestamp", "stopTimestamp", "runVideoExistsInPlaylistCheck", "otherPlaylists", "updateVideoOfPlaylist", "existsResult", "elem", "e", "removeVideoFromPlaylist", "reorderPlaylist", "oldPosition", "newPosition", "startPosition", "insertAfterPosition", "getPlaylistVideos", "options", "path", "videoPlaylistId", "extractVideoPlaylistElements", "listenToMyAccountPlaylistsChange", "asObservable", "listenToVideoPlaylistChange", "r", "getServerLocale", "translations", "playlistsJSON", "playlists", "playlistJSON", "VideoPlaylist", "elementsJson", "elements", "elementJson", "VideoPlaylistElement", "MY_VIDEO_PLAYLIST_URL", "context", "HttpContext", "set", "NGX_LOADING_BAR_IGNORED", "__publicField", "environment", "apiUrl", "factory", "\u0275fac", "_VideoPlaylistService"]
}
